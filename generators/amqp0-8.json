{
  "amqp": "\n    AMQ Protocol 0.80\n<constantname=\"frame method\" value=\"1\"><\/constant><constantname=\"frame header\" value=\"2\"><\/constant><constantname=\"frame body\" value=\"3\"><\/constant><constantname=\"frame oob method\" value=\"4\"><\/constant><constantname=\"frame oob header\" value=\"5\"><\/constant><constantname=\"frame oob body\" value=\"6\"><\/constant><constantname=\"frame trace\" value=\"7\"><\/constant><constantname=\"frame heartbeat\" value=\"8\"><\/constant><constantname=\"frame min size\" value=\"4096\"><\/constant><constantname=\"frame end\" value=\"206\"><\/constant><constantname=\"reply success\" value=\"200\">\n  Indicates that the method completed successfully. This reply code is\n  reserved for future use - the current protocol design does not use\n  positive confirmation and reply codes are sent only in case of an\n  error.\n<\/constant><constantname=\"not delivered\" class=\"soft error\" value=\"310\">\n  The client asked for a specific message that is no longer available.\n  The message was delivered to another client, or was purged from the\n  queue for some other reason.\n<\/constant><constantname=\"content too large\" class=\"soft error\" value=\"311\">\n  The client attempted to transfer content larger than the server\n  could accept at the present time.  The client may retry at a later\n  time.\n<\/constant><constantname=\"connection forced\" class=\"hard error\" value=\"320\">\n  An operator intervened to close the connection for some reason.\n  The client may retry at some later date.\n<\/constant><constantname=\"invalid path\" class=\"hard error\" value=\"402\">\n  The client tried to work with an unknown virtual host or cluster.\n<\/constant><constantname=\"access refused\" class=\"soft error\" value=\"403\">\n  The client attempted to work with a server entity to which it has\n  no  due to security settings.\n<\/constant><constantname=\"not found\" class=\"soft error\" value=\"404\">\n  The client attempted to work with a server entity that does not exist.\n<\/constant><constantname=\"resource locked\" class=\"soft error\" value=\"405\">\n  The client attempted to work with a server entity to which it has\n  no access because another client is working with it.\n<\/constant><constantname=\"frame error\" class=\"hard error\" value=\"501\">\n  The client sent a malformed frame that the server could not decode.\n  This strongly implies a programming error in the client.\n<\/constant><constantname=\"syntax error\" class=\"hard error\" value=\"502\">\n  The client sent a frame that contained illegal values for one or more\n  fields.  This strongly implies a programming error in the client.\n<\/constant><constantname=\"command invalid\" class=\"hard error\" value=\"503\">\n  The client sent an invalid sequence of frames, attempting to perform\n  an operation that was considered invalid by the server. This usually\n  implies a programming error in the client.\n<\/constant><constantname=\"channel error\" class=\"hard error\" value=\"504\">\n  The client attempted to work with a channel that had not been\n  correctly opened.  This most likely indicates a fault in the client\n  layer.\n<\/constant><constantname=\"resource error\" class=\"hard error\" value=\"506\">\n  The server could not complete the method because it lacked sufficient\n  resources. This may be due to the client creating too many of some\n  type of entity.\n<\/constant><constantname=\"not allowed\" class=\"hard error\" value=\"530\">\n  The client tried to work with some entity in a manner that is\n  prohibited by the server, due to security settings or by some other\n  criteria.\n<\/constant><constantname=\"not implemented\" class=\"hard error\" value=\"540\">\n  The client tried to use functionality that is not implemented in the\n  server.\n<\/constant><constantname=\"internal error\" class=\"hard error\" value=\"541\">\n  The server could not complete the method because of an internal error.\n  The server may require intervention by an operator in order to resume\n  normal operations.\n<\/constant><domaintype=\"short\" name=\"access ticket\" type=\"short\">\n    access ticket granted by server\n    <doc>\n    An access ticket granted by the server for a certain set of access\n    rights within a specific realm. Access tickets are valid within the\n    channel where they were created, and expire when the channel closes.\n    <\/doc><assertvalue=\"0\" check=\"ne\"><\/assert><\/domain><domaintype=\"short\" name=\"class id\" type=\"short\"><\/domain><domaintype=\"shortstr\" name=\"consumer tag\" type=\"shortstr\">\n    consumer tag\n    <doc>\n      Identifier for the consumer, valid within the current connection.\n    <\/doc><ruleimplement=\"MUST\">\n      The consumer tag is valid only within the channel from which the\n      consumer was created. I.e. a client MUST NOT create a consumer in\n      one channel and then use it in another.\n    <\/rule><\/domain><domaintype=\"longlong\" name=\"delivery tag\" type=\"longlong\">\n    server-assigned delivery tag\n    <doc>\n      The server-assigned and channel-specific delivery tag\n    <\/doc><ruleimplement=\"MUST\">\n      The delivery tag is valid only within the channel from which the\n      message was received.  I.e. a client MUST NOT receive a message on\n      one channel and then acknowledge it on another.\n    <\/rule><ruleimplement=\"MUST\">\n      The server MUST NOT use a zero value for delivery tags.  Zero is\n      reserved for client use, meaning \"all messages so far received\".\n    <\/rule><\/domain><domaintype=\"shortstr\" name=\"exchange name\" type=\"shortstr\">\n    exchange name\n    <doc>\n      The exchange name is a client-selected string that identifies\n      the exchange for publish methods.  Exchange names may consist\n      of any mixture of digits, letters, and underscores.  Exchange\n      names are scoped by the virtual host.\n    <\/doc><assertvalue=\"127\" check=\"length\"><\/assert><\/domain><domaintype=\"shortstr\" name=\"known hosts\" type=\"shortstr\">\nlist of known hosts\n<doc>\nSpecifies the list of equivalent or alternative hosts that the server\nknows about, which will normally include the current server itself.\nClients can cache this information and use it when reconnecting to a\nserver after a failure.\n<\/doc><ruleimplement=\"MAY\">\nThe server MAY leave this field empty if it knows of no other\nhosts than itself.\n<\/rule><\/domain><domaintype=\"short\" name=\"method id\" type=\"short\"><\/domain><domaintype=\"bit\" name=\"no ack\" type=\"bit\">\n    no acknowledgement needed\n    <doc>\n      If this field is set the server does not expect acknowledgments\n      for messages.  That is, when a message is delivered to the client\n      the server automatically and silently acknowledges it on behalf\n      of the client.  This functionality increases performance but at\n      the cost of reliability.  Messages can get lost if a client dies\n      before it can deliver them to the application.\n    <\/doc><\/domain><domaintype=\"bit\" name=\"no local\" type=\"bit\">\n    do not deliver own messages\n    <doc>\n    If the no-local field is set the server will not send messages to\n    the client that published them.\n    <\/doc><\/domain><domaintype=\"shortstr\" name=\"path\" type=\"shortstr\"><doc>\n  Must start with a slash \"\/\" and continue with path names\n  separated by slashes. A path name consists of any combination\n  of at least one of [A-Za-z0-9] plus zero or more of [.-_+!=:].\n<\/doc><assertcheck=\"notnull\"><\/assert><assertcheck=\"syntax\" rule=\"path\"><\/assert><assertvalue=\"127\" check=\"length\"><\/assert><\/domain><domaintype=\"table\" name=\"peer properties\" type=\"table\"><doc>\nThis string provides a set of peer properties, used for\nidentification, debugging, and general information.\n<\/doc><ruleimplement=\"SHOULD\">\nThe properties SHOULD contain these fields:\n\"product\", giving the name of the peer product, \"version\", giving\nthe name of the peer version, \"platform\", giving the name of the\noperating system, \"copyright\", if appropriate, and \"information\",\ngiving other general information.\n<\/rule><\/domain><domaintype=\"shortstr\" name=\"queue name\" type=\"shortstr\">\n    queue name\n    <doc>\n    The queue name identifies the queue within the vhost.  Queue\n    names may consist of any mixture of digits, letters, and\n    underscores.\n    <\/doc><assertvalue=\"127\" check=\"length\"><\/assert><\/domain><domaintype=\"bit\" name=\"redelivered\" type=\"bit\">\n    message is being redelivered\n    <doc>\n      This indicates that the message has been previously delivered to\n      this or another client.\n    <\/doc><ruleimplement=\"SHOULD\">\n      The server SHOULD try to signal redelivered messages when it can.\n      When redelivering a message that was not successfully acknowledged,\n      the server SHOULD deliver it to the original client if possible.\n    <\/rule><ruleimplement=\"MUST\">\n      The client MUST NOT rely on the redelivered field but MUST take it\n      as a hint that the message may already have been processed.  A\n      fully robust client must be able to track duplicate received messages\n      on non-transacted, and locally-transacted channels.\n    <\/rule><\/domain><domaintype=\"short\" name=\"reply code\" type=\"short\">\nreply code from server\n<doc>\n  The reply code. The AMQ reply codes are defined in AMQ RFC 011.\n<\/doc><assertcheck=\"notnull\"><\/assert><\/domain><domaintype=\"shortstr\" name=\"reply text\" type=\"shortstr\">\nlocalised reply text\n<doc>\n  The localised reply text.  This text can be logged as an aid to\n  resolving issues.\n<\/doc><assertcheck=\"notnull\"><\/assert><\/domain><classname=\"connection\" handler=\"connection\" index=\"10\">\n  work with socket connections\n<doc>\n  The connection class provides methods for a client to establish a\n  network connection to a server, and for both peers to operate the\n  connection thereafter.\n<\/doc><docname=\"grammar\">\n    connection          = open-connection *use-connection close-connection\n    open-connection     = C:protocol-header\n                          S:START C:START-OK\n                          *challenge\n                          S:TUNE C:TUNE-OK\n                          C:OPEN S:OPEN-OK | S:REDIRECT\n    challenge           = S:SECURE C:SECURE-OK\n    use-connection      = *channel\n    close-connection    = C:CLOSE S:CLOSE-OK\n                        \/ S:CLOSE C:CLOSE-OK\n<\/doc><chassisname=\"server\" implement=\"MUST\"><\/chassis><chassisname=\"client\" implement=\"MUST\"><\/chassis><methodname=\"start\" index=\"10\" synchronous=\"1\">\n  start connection negotiation\n  <doc>\n    This method starts the connection negotiation process by telling\n    the client the protocol version that the server proposes, along\n    with a list of security mechanisms which the client can use for\n    authentication.\n  <\/doc><ruleimplement=\"MUST\">\n    If the client cannot handle the protocol version suggested by the\n    server it MUST close the socket connection.\n  <\/rule><ruleimplement=\"MUST\">\n    The server MUST provide a protocol version that is lower than or\n    equal to that requested by the client in the protocol header. If\n    the server cannot support the specified protocol it MUST NOT send\n    this method, but MUST close the socket connection.\n  <\/rule><chassisname=\"client\" implement=\"MUST\"><\/chassis><responsename=\"start-ok\"><\/response><fieldtype=\"octet\" name=\"version major\" type=\"octet\">\n    protocol major version\n    <doc>\n      The protocol major version that the server agrees to use, which\n      cannot be higher than the client's major version.\n    <\/doc><\/field><fieldtype=\"octet\" name=\"version minor\" type=\"octet\">\n    protocol major version\n    <doc>\n      The protocol minor version that the server agrees to use, which\n      cannot be higher than the client's minor version.\n    <\/doc><\/field><fieldname=\"server properties\" domain=\"peer properties\">\n    server properties\n  <\/field><fieldtype=\"longstr\" name=\"mechanisms\" type=\"longstr\">\n    available security mechanisms\n    <doc>\n      A list of the security mechanisms that the server supports, delimited\n      by spaces.  Currently ASL supports these mechanisms: PLAIN.\n    <\/doc><seename=\"security mechanisms\"><\/see><assertcheck=\"notnull\"><\/assert><\/field><fieldtype=\"longstr\" name=\"locales\" type=\"longstr\">\n    available message locales\n    <doc>\n      A list of the message locales that the server supports, delimited\n      by spaces.  The locale defines the language in which the server\n      will send reply texts.\n    <\/doc><ruleimplement=\"MUST\">\n      All servers MUST support at least the en_US locale.\n    <\/rule><assertcheck=\"notnull\"><\/assert><\/field><\/method><methodname=\"start-ok\" index=\"11\" synchronous=\"1\">\n  select security mechanism and locale\n  <doc>\n    This method selects a SASL security mechanism. ASL uses SASL\n    (RFC2222) to negotiate authentication and encryption.\n  <\/doc><chassisname=\"server\" implement=\"MUST\"><\/chassis><fieldname=\"client properties\" domain=\"peer properties\">\n    client properties\n  <\/field><fieldtype=\"shortstr\" name=\"mechanism\" type=\"shortstr\">\n    selected security mechanism\n    <doc>\n      A single security mechanisms selected by the client, which must be\n      one of those specified by the server.\n    <\/doc><ruleimplement=\"SHOULD\">\n      The client SHOULD authenticate using the highest-level security\n      profile it can handle from the list provided by the server.\n    <\/rule><ruleimplement=\"MUST\">\n    The mechanism field MUST contain one of the security mechanisms\n    proposed by the server in the Start method. If it doesn't, the\n    server MUST close the socket.\n    <\/rule><assertcheck=\"notnull\"><\/assert><\/field><fieldtype=\"longstr\" name=\"response\" type=\"longstr\">\n    security response data\n    <doc>\n      A block of opaque data passed to the security mechanism. The contents\n      of this data are defined by the SASL security mechanism.  For the\n      PLAIN security mechanism this is defined as a field table holding\n      two fields, LOGIN and PASSWORD.\n    <\/doc><assertcheck=\"notnull\"><\/assert><\/field><fieldtype=\"shortstr\" name=\"locale\" type=\"shortstr\">\n    selected message locale\n    <doc>\n      A single message local selected by the client, which must be one\n      of those specified by the server.\n    <\/doc><assertcheck=\"notnull\"><\/assert><\/field><\/method><methodname=\"secure\" index=\"20\" synchronous=\"1\">\n  security mechanism challenge\n  <doc>\n    The SASL protocol works by exchanging challenges and responses until\n    both peers have received sufficient information to authenticate each\n    other.  This method challenges the client to provide more information.\n  <\/doc><chassisname=\"client\" implement=\"MUST\"><\/chassis><responsename=\"secure-ok\"><\/response><fieldtype=\"longstr\" name=\"challenge\" type=\"longstr\">\n    security challenge data\n    <doc>\n      Challenge information, a block of opaque binary data passed to\n      the security mechanism.\n    <\/doc><seename=\"security mechanisms\"><\/see><\/field><\/method><methodname=\"secure-ok\" index=\"21\" synchronous=\"1\">\n  security mechanism response\n  <doc>\n    This method attempts to authenticate, passing a block of SASL data\n    for the security mechanism at the server side.\n  <\/doc><chassisname=\"server\" implement=\"MUST\"><\/chassis><fieldtype=\"longstr\" name=\"response\" type=\"longstr\">\n    security response data\n    <doc>\n      A block of opaque data passed to the security mechanism.  The contents\n      of this data are defined by the SASL security mechanism.\n    <\/doc><assertcheck=\"notnull\"><\/assert><\/field><\/method><methodname=\"tune\" index=\"30\" synchronous=\"1\">\n  propose connection tuning parameters\n  <doc>\n    This method proposes a set of connection configuration values\n    to the client.  The client can accept and\/or adjust these.\n  <\/doc><chassisname=\"client\" implement=\"MUST\"><\/chassis><responsename=\"tune-ok\"><\/response><fieldtype=\"short\" name=\"channel max\" type=\"short\">\n    proposed maximum channels\n    <doc>\n      The maximum total number of channels that the server allows\n      per connection. Zero means that the server does not impose a\n      fixed limit, but the number of allowed channels may be limited\n      by available server resources.\n    <\/doc><\/field><fieldtype=\"long\" name=\"frame max\" type=\"long\">\n    proposed maximum frame size\n    <doc>\n      The largest frame size that the server proposes for the\n      connection. The client can negotiate a lower value.  Zero means\n      that the server does not impose any specific limit but may reject\n      very large frames if it cannot allocate resources for them.\n    <\/doc><ruleimplement=\"MUST\">\n      Until the frame-max has been negotiated, both peers MUST accept\n      frames of up to 4096 octets large. The minimum non-zero value for\n      the frame-max field is 4096.\n    <\/rule><\/field><fieldtype=\"short\" name=\"heartbeat\" type=\"short\">\n    desired heartbeat delay\n    <doc>\n      The delay, in seconds, of the connection heartbeat that the server\n      wants.  Zero means the server does not want a heartbeat.\n    <\/doc><\/field><\/method><methodname=\"tune-ok\" index=\"31\" synchronous=\"1\">\n  negotiate connection tuning parameters\n  <doc>\n    This method sends the client's connection tuning parameters to the\n    server. Certain fields are negotiated, others provide capability\n    information.\n  <\/doc><chassisname=\"server\" implement=\"MUST\"><\/chassis><fieldtype=\"short\" name=\"channel max\" type=\"short\">\n    negotiated maximum channels\n    <doc>\n      The maximum total number of channels that the client will use\n      per connection.  May not be higher than the value specified by\n      the server.\n    <\/doc><ruleimplement=\"MAY\">\n      The server MAY ignore the channel-max value or MAY use it for\n      tuning its resource allocation.\n    <\/rule><assertcheck=\"notnull\"><\/assert><assertfield=\"channel max\" method=\"tune\" check=\"le\"><\/assert><\/field><fieldtype=\"long\" name=\"frame max\" type=\"long\">\n    negotiated maximum frame size\n    <doc>\n      The largest frame size that the client and server will use for\n      the connection.  Zero means that the client does not impose any\n      specific limit but may reject very large frames if it cannot\n      allocate resources for them.  Note that the frame-max limit\n      applies principally to content frames, where large contents\n      can be broken into frames of arbitrary size.\n    <\/doc><ruleimplement=\"MUST\">\n      Until the frame-max has been negotiated, both peers must accept\n      frames of up to 4096 octets large. The minimum non-zero value for\n      the frame-max field is 4096.\n    <\/rule><\/field><fieldtype=\"short\" name=\"heartbeat\" type=\"short\">\n    desired heartbeat delay\n    <doc>\n      The delay, in seconds, of the connection heartbeat that the client\n      wants. Zero means the client does not want a heartbeat.\n    <\/doc><\/field><\/method><methodname=\"open\" index=\"40\" synchronous=\"1\">\n  open connection to virtual host\n  <doc>\n    This method opens a connection to a virtual host, which is a\n    collection of resources, and acts to separate multiple application\n    domains within a server.\n  <\/doc><ruleimplement=\"MUST\">\n    The client MUST open the context before doing any work on the\n    connection.\n  <\/rule><chassisname=\"server\" implement=\"MUST\"><\/chassis><responsename=\"open-ok\"><\/response><responsename=\"redirect\"><\/response><fieldname=\"virtual host\" domain=\"path\">\n    virtual host name\n    <assertvalue=\"^[a-zA-Z0-9\/-_]+$\" check=\"regexp\"><\/assert><doc>\n      The name of the virtual host to work with.\n    <\/doc><ruleimplement=\"MUST\">\n      If the server supports multiple virtual hosts, it MUST enforce a\n      full separation of exchanges, queues, and all associated entities\n      per virtual host. An application, connected to a specific virtual\n      host, MUST NOT be able to access resources of another virtual host.\n    <\/rule><ruleimplement=\"SHOULD\">\n      The server SHOULD verify that the client has permission to access\n      the specified virtual host.\n    <\/rule><ruleimplement=\"MAY\">\n      The server MAY configure arbitrary limits per virtual host, such\n      as the number of each type of entity that may be used, per\n      connection and\/or in total.\n    <\/rule><\/field><fieldtype=\"shortstr\" name=\"capabilities\" type=\"shortstr\">\n    required capabilities\n    <doc>\n      The client may specify a number of capability names, delimited by\n      spaces.  The server can use this string to how to process the\n      client's connection request.\n    <\/doc><\/field><fieldtype=\"bit\" name=\"insist\" type=\"bit\">\n    insist on connecting to server\n    <doc>\n      In a configuration with multiple load-sharing servers, the server\n      may respond to a Connection.Open method with a Connection.Redirect.\n      The insist option tells the server that the client is insisting on\n      a connection to the specified server.\n    <\/doc><ruleimplement=\"SHOULD\">\n      When the client uses the insist option, the server SHOULD accept\n      the client connection unless it is technically unable to do so.\n    <\/rule><\/field><\/method><methodname=\"open-ok\" index=\"41\" synchronous=\"1\">\n  signal that the connection is ready\n  <doc>\n    This method signals to the client that the connection is ready for\n    use.\n  <\/doc><chassisname=\"client\" implement=\"MUST\"><\/chassis><fieldname=\"known hosts\" domain=\"known hosts\"><\/field><\/method><methodname=\"redirect\" index=\"50\" synchronous=\"1\">\n  asks the client to use a different server\n  <doc>\n    This method redirects the client to another server, based on the\n    requested virtual host and\/or capabilities.\n  <\/doc><ruleimplement=\"SHOULD\">\n    When getting the Connection.Redirect method, the client SHOULD\n    reconnect to the host specified, and if that host is not present,\n    to any of the hosts specified in the known-hosts list.\n  <\/rule><chassisname=\"client\" implement=\"MAY\"><\/chassis><fieldtype=\"shortstr\" name=\"host\" type=\"shortstr\">\n    server to connect to\n    <doc>\n      Specifies the server to connect to.  This is an IP address or a\n      DNS name, optionally followed by a colon and a port number. If\n      no port number is specified, the client should use the default\n      port number for the protocol.\n    <\/doc><assertcheck=\"notnull\"><\/assert><\/field><fieldname=\"known hosts\" domain=\"known hosts\"><\/field><\/method><methodname=\"close\" index=\"60\" synchronous=\"1\">\n  request a connection close\n  <doc>\n    This method indicates that the sender wants to close the connection.\n    This may be due to internal conditions (e.g. a forced shut-down) or\n    due to an error handling a specific method, i.e. an exception.  When\n    a close is due to an exception, the sender provides the class and\n    method id of the method which caused the exception.\n  <\/doc><ruleimplement=\"MUST\">\n    After sending this method any received method except the Close-OK\n    method MUST be discarded.\n  <\/rule><ruleimplement=\"MAY\">\n    The peer sending this method MAY use a counter or timeout to\n    detect failure of the other peer to respond correctly with\n    the Close-OK method.\n  <\/rule><ruleimplement=\"MUST\">\n    When a server receives the Close method from a client it MUST\n    delete all server-side resources associated with the client's\n    context.  A client CANNOT reconnect to a context after sending\n    or receiving a Close method.\n  <\/rule><chassisname=\"client\" implement=\"MUST\"><\/chassis><chassisname=\"server\" implement=\"MUST\"><\/chassis><responsename=\"close-ok\"><\/response><fieldname=\"reply code\" domain=\"reply code\"><\/field><fieldname=\"reply text\" domain=\"reply text\"><\/field><fieldname=\"class id\" domain=\"class id\">\n    failing method class\n    <doc>\n      When the close is provoked by a method exception, this is the\n      class of the method.\n    <\/doc><\/field><fieldname=\"method id\" domain=\"class id\">\n    failing method ID\n    <doc>\n      When the close is provoked by a method exception, this is the\n      ID of the method.\n    <\/doc><\/field><\/method><methodname=\"close-ok\" index=\"61\" synchronous=\"1\">\n  confirm a connection close\n  <doc>\n    This method confirms a Connection.Close method and tells the\n    recipient that it is safe to release resources for the connection\n    and close the socket.\n  <\/doc><ruleimplement=\"SHOULD\">\n    A peer that detects a socket closure without having received a\n    Close-Ok handshake method SHOULD log the error.\n  <\/rule><chassisname=\"client\" implement=\"MUST\"><\/chassis><chassisname=\"server\" implement=\"MUST\"><\/chassis><\/method><\/class><classname=\"channel\" handler=\"channel\" index=\"20\">\n  work with channels\n<doc>\n  The channel class provides methods for a client to establish a virtual\n  connection - a channel - to a server and for both peers to operate the\n  virtual connection thereafter.\n<\/doc><docname=\"grammar\">\n    channel             = open-channel *use-channel close-channel\n    open-channel        = C:OPEN S:OPEN-OK\n    use-channel         = C:FLOW S:FLOW-OK\n                        \/ S:FLOW C:FLOW-OK\n                        \/ S:ALERT\n                        \/ functional-class\n    close-channel       = C:CLOSE S:CLOSE-OK\n                        \/ S:CLOSE C:CLOSE-OK\n<\/doc><chassisname=\"server\" implement=\"MUST\"><\/chassis><chassisname=\"client\" implement=\"MUST\"><\/chassis><methodname=\"open\" index=\"10\" synchronous=\"1\">\n  open a channel for use\n  <doc>\n    This method opens a virtual connection (a channel).\n  <\/doc><ruleimplement=\"MUST\">\n    This method MUST NOT be called when the channel is already open.\n  <\/rule><chassisname=\"server\" implement=\"MUST\"><\/chassis><responsename=\"open-ok\"><\/response><fieldtype=\"shortstr\" name=\"out of band\" type=\"shortstr\">\n    out-of-band settings\n    <doc>\n      Configures out-of-band transfers on this channel.  The syntax and\n      meaning of this field will be formally defined at a later date.\n    <\/doc><assertcheck=\"null\"><\/assert><\/field><\/method><methodname=\"open-ok\" index=\"11\" synchronous=\"1\">\n  signal that the channel is ready\n  <doc>\n    This method signals to the client that the channel is ready for use.\n  <\/doc><chassisname=\"client\" implement=\"MUST\"><\/chassis><\/method><methodname=\"flow\" index=\"20\" synchronous=\"1\">\n  enable\/disable flow from peer\n  <doc>\n    This method asks the peer to pause or restart the flow of content\n    data. This is a simple flow-control mechanism that a peer can use\n    to avoid oveflowing its queues or otherwise finding itself receiving\n    more messages than it can process.  Note that this method is not\n    intended for window control.  The peer that receives a request to\n    stop sending content should finish sending the current content, if\n    any, and then wait until it receives a Flow restart method.\n  <\/doc><ruleimplement=\"MAY\">\n    When a new channel is opened, it is active.  Some applications\n    assume that channels are inactive until started.  To emulate this\n    behaviour a client MAY open the channel, then pause it.\n  <\/rule><ruleimplement=\"SHOULD\">\n    When sending content data in multiple frames, a peer SHOULD monitor\n    the channel for incoming methods and respond to a Channel.Flow as\n    rapidly as possible.\n  <\/rule><ruleimplement=\"MAY\">\n    A peer MAY use the Channel.Flow method to throttle incoming content\n    data for internal reasons, for example, when exchangeing data over a\n    slower connection.\n  <\/rule><ruleimplement=\"MAY\">\n    The peer that requests a Channel.Flow method MAY disconnect and\/or\n    ban a peer that does not respect the request.\n  <\/rule><chassisname=\"server\" implement=\"MUST\"><\/chassis><chassisname=\"client\" implement=\"MUST\"><\/chassis><responsename=\"flow-ok\"><\/response><fieldtype=\"bit\" name=\"active\" type=\"bit\">\n    start\/stop content frames\n    <doc>\n      If 1, the peer starts sending content frames.  If 0, the peer\n      stops sending content frames.\n    <\/doc><\/field><\/method><methodname=\"flow-ok\" index=\"21\">\n  confirm a flow method\n  <doc>\n    Confirms to the peer that a flow command was received and processed.\n  <\/doc><chassisname=\"server\" implement=\"MUST\"><\/chassis><chassisname=\"client\" implement=\"MUST\"><\/chassis><fieldtype=\"bit\" name=\"active\" type=\"bit\">\n    current flow setting\n    <doc>\n      Confirms the setting of the processed flow method: 1 means the\n      peer will start sending or continue to send content frames; 0\n      means it will not.\n    <\/doc><\/field><\/method><methodname=\"alert\" index=\"30\">\n  send a non-fatal warning message\n  <doc>\n    This method allows the server to send a non-fatal warning to the\n    client.  This is used for methods that are normally asynchronous\n    and thus do not have confirmations, and for which the server may\n    detect errors that need to be reported.  Fatal errors are handled\n    as channel or connection exceptions; non-fatal errors are sent\n    through this method.\n  <\/doc><chassisname=\"client\" implement=\"MUST\"><\/chassis><fieldname=\"reply code\" domain=\"reply code\"><\/field><fieldname=\"reply text\" domain=\"reply text\"><\/field><fieldtype=\"table\" name=\"details\" type=\"table\">\n    detailed information for warning\n    <doc>\n      A set of fields that provide more information about the\n      problem.  The meaning of these fields are defined on a\n      per-reply-code basis (TO BE DEFINED).\n    <\/doc><\/field><\/method><methodname=\"close\" index=\"40\" synchronous=\"1\">\n  request a channel close\n  <doc>\n    This method indicates that the sender wants to close the channel.\n    This may be due to internal conditions (e.g. a forced shut-down) or\n    due to an error handling a specific method, i.e. an exception.  When\n    a close is due to an exception, the sender provides the class and\n    method id of the method which caused the exception.\n  <\/doc><ruleimplement=\"MUST\">\n    After sending this method any received method except\n    Channel.Close-OK MUST be discarded.\n  <\/rule><ruleimplement=\"MAY\">\n    The peer sending this method MAY use a counter or timeout to detect\n    failure of the other peer to respond correctly with Channel.Close-OK..\n  <\/rule><chassisname=\"client\" implement=\"MUST\"><\/chassis><chassisname=\"server\" implement=\"MUST\"><\/chassis><responsename=\"close-ok\"><\/response><fieldname=\"reply code\" domain=\"reply code\"><\/field><fieldname=\"reply text\" domain=\"reply text\"><\/field><fieldname=\"class id\" domain=\"class id\">\n    failing method class\n    <doc>\n      When the close is provoked by a method exception, this is the\n      class of the method.\n    <\/doc><\/field><fieldname=\"method id\" domain=\"method id\">\n    failing method ID\n    <doc>\n      When the close is provoked by a method exception, this is the\n      ID of the method.\n    <\/doc><\/field><\/method><methodname=\"close-ok\" index=\"41\" synchronous=\"1\">\n  confirm a channel close\n  <doc>\n    This method confirms a Channel.Close method and tells the recipient\n    that it is safe to release resources for the channel and close the\n    socket.\n  <\/doc><ruleimplement=\"SHOULD\">\n    A peer that detects a socket closure without having received a\n    Channel.Close-Ok handshake method SHOULD log the error.\n  <\/rule><chassisname=\"client\" implement=\"MUST\"><\/chassis><chassisname=\"server\" implement=\"MUST\"><\/chassis><\/method><\/class><classname=\"access\" handler=\"connection\" index=\"30\">\n  work with access tickets\n<doc>\n  The protocol control access to server resources using access tickets.\n  A client must explicitly request access tickets before doing work.\n  An access ticket grants a client the right to use a specific set of\n  resources - called a \"realm\" - in specific ways.\n<\/doc><docname=\"grammar\">\n    access              = C:REQUEST S:REQUEST-OK\n<\/doc><chassisname=\"server\" implement=\"MUST\"><\/chassis><chassisname=\"client\" implement=\"MUST\"><\/chassis><methodname=\"request\" index=\"10\" synchronous=\"1\">\n  request an access ticket\n  <doc>\n    This method requests an access ticket for an access realm.\n    The server responds by granting the access ticket.  If the\n    client does not have access rights to the requested realm\n    this causes a connection exception.  Access tickets are a\n    per-channel resource.\n  <\/doc><ruleimplement=\"MUST\">\n    The realm name MUST start with either \"\/data\" (for application\n    resources) or \"\/admin\" (for server administration resources).\n    If the realm starts with any other path, the server MUST raise\n    a connection exception with reply code 403 (access refused).\n  <\/rule><ruleimplement=\"MUST\">\n    The server MUST implement the \/data realm and MAY implement the\n    \/admin realm.  The mapping of resources to realms is not\n    defined in the protocol - this is a server-side configuration\n    issue.\n  <\/rule><chassisname=\"server\" implement=\"MUST\"><\/chassis><responsename=\"request-ok\"><\/response><fieldname=\"realm\" domain=\"path\">\n    name of requested realm\n    <ruleimplement=\"MUST\">\n      If the specified realm is not known to the server, the server\n      must raise a channel exception with reply code 402 (invalid\n      path).\n    <\/rule><\/field><fieldtype=\"bit\" name=\"exclusive\" type=\"bit\">\n    request exclusive access\n    <doc>\n      Request exclusive access to the realm. If the server cannot grant\n      this - because there are other active tickets for the realm - it\n      raises a channel exception.\n    <\/doc><\/field><fieldtype=\"bit\" name=\"passive\" type=\"bit\">\n    request passive access\n    <doc>\n      Request message passive access to the specified access realm.\n      Passive access lets a client get information about resources in\n      the realm but not to make any changes to them.\n    <\/doc><\/field><fieldtype=\"bit\" name=\"active\" type=\"bit\">\n    request active access\n    <doc>\n      Request message active access to the specified access realm.\n      Acvtive access lets a client get create and delete resources in\n      the realm.\n    <\/doc><\/field><fieldtype=\"bit\" name=\"write\" type=\"bit\">\n    request write access\n    <doc>\n      Request write access to the specified access realm.  Write access\n      lets a client publish messages to all exchanges in the realm.\n    <\/doc><\/field><fieldtype=\"bit\" name=\"read\" type=\"bit\">\n    request read access\n    <doc>\n      Request read access to the specified access realm.  Read access\n      lets a client consume messages from queues in the realm.\n    <\/doc><\/field><\/method><methodname=\"request-ok\" index=\"11\" synchronous=\"1\">\n  grant access to server resources\n  <doc>\n    This method provides the client with an access ticket. The access\n    ticket is valid within the current channel and for the lifespan of\n    the channel.\n  <\/doc><ruleimplement=\"MUST\">\n    The client MUST NOT use access tickets except within the same\n    channel as originally granted.\n  <\/rule><ruleimplement=\"MUST\">\n    The server MUST isolate access tickets per channel and treat an\n    attempt by a client to mix these as a connection exception.\n  <\/rule><chassisname=\"client\" implement=\"MUST\"><\/chassis><fieldname=\"ticket\" domain=\"access ticket\"><\/field><\/method><\/class><classname=\"exchange\" handler=\"channel\" index=\"40\">\n  work with exchanges\n<doc>\n  Exchanges match and distribute messages across queues.  Exchanges can be\n  configured in the server or created at runtime.\n<\/doc><docname=\"grammar\">\n    exchange            = C:DECLARE  S:DECLARE-OK\n                        \/ C:DELETE   S:DELETE-OK\n<\/doc><chassisname=\"server\" implement=\"MUST\"><\/chassis><chassisname=\"client\" implement=\"MUST\"><\/chassis><ruleimplement=\"MUST\"><test>amq_exchange_19<\/test>\n  The server MUST implement the direct and fanout exchange types, and\n  predeclare the corresponding exchanges named amq.direct and amq.fanout\n  in each virtual host. The server MUST also predeclare a direct\n  exchange to act as the default exchange for content Publish methods\n  and for default queue bindings.\n<\/rule><ruleimplement=\"SHOULD\"><test>amq_exchange_20<\/test>\n  The server SHOULD implement the topic exchange type, and predeclare\n  the corresponding exchange named amq.topic in each virtual host.\n<\/rule><ruleimplement=\"MAY\"><test>amq_exchange_21<\/test>\n  The server MAY implement the system exchange type, and predeclare the\n  corresponding exchanges named amq.system in each virtual host. If the\n  client attempts to bind a queue to the system exchange, the server\n  MUST raise a connection exception with reply code 507 (not allowed).\n<\/rule><ruleimplement=\"MUST\"><test>amq_exchange_22<\/test>\n  The default exchange MUST be defined as internal, and be inaccessible\n  to the client except by specifying an empty exchange name in a content\n  Publish method. That is, the server MUST NOT let clients make explicit\n  bindings to this exchange.\n<\/rule><methodname=\"declare\" index=\"10\" synchronous=\"1\">\n  declare exchange, create if needed\n  <doc>\n    This method creates an exchange if it does not already exist, and if the\n    exchange exists, verifies that it is of the correct and expected class.\n  <\/doc><ruleimplement=\"SHOULD\"><test>amq_exchange_23<\/test>\n    The server SHOULD support a minimum of 16 exchanges per virtual host\n    and ideally, impose no limit except as defined by available resources.\n  <\/rule><chassisname=\"server\" implement=\"MUST\"><\/chassis><responsename=\"declare-ok\"><\/response><fieldname=\"ticket\" domain=\"access ticket\"><doc>\n      When a client defines a new exchange, this belongs to the access realm\n      of the ticket used.  All further work done with that exchange must be\n      done with an access ticket for the same realm.\n    <\/doc><ruleimplement=\"MUST\">\n      The client MUST provide a valid access ticket giving \"active\" access\n      to the realm in which the exchange exists or will be created, or\n      \"passive\" access if the if-exists flag is set.\n    <\/rule><\/field><fieldname=\"exchange\" domain=\"exchange name\"><ruleimplement=\"MUST\"><test>amq_exchange_15<\/test>\n      Exchange names starting with \"amq.\" are reserved for predeclared\n      and standardised exchanges.  If the client attempts to create an\n      exchange starting with \"amq.\", the server MUST raise a channel\n      exception with reply code 403 (access refused).\n    <\/rule><assertvalue=\"^[a-zA-Z0-9-_.:]+$\" check=\"regexp\"><\/assert><\/field><fieldtype=\"shortstr\" name=\"type\" type=\"shortstr\">\n    exchange type\n    <doc>\n      Each exchange belongs to one of a set of exchange types implemented\n      by the server.  The exchange types define the functionality of the\n      exchange - i.e. how messages are routed through it.  It is not valid\n      or meaningful to attempt to change the type of an existing exchange.\n    <\/doc><ruleimplement=\"MUST\"><test>amq_exchange_16<\/test>\n      If the exchange already exists with a different type, the server\n      MUST raise a connection exception with a reply code 507 (not allowed).\n    <\/rule><ruleimplement=\"MUST\"><test>amq_exchange_18<\/test>\n      If the server does not support the requested exchange type it MUST\n      raise a connection exception with a reply code 503 (command invalid).\n    <\/rule><assertvalue=\"^[a-zA-Z0-9-_.:]+$\" check=\"regexp\"><\/assert><\/field><fieldtype=\"bit\" name=\"passive\" type=\"bit\">\n    do not create exchange\n    <doc>\n    If set, the server will not create the exchange.  The client can use\n    this to check whether an exchange exists without modifying the server\n    state.\n    <\/doc><ruleimplement=\"MUST\"><test>amq_exchange_05<\/test>\n      If set, and the exchange does not already exist, the server MUST\n      raise a channel exception with reply code 404 (not found).\n    <\/rule><\/field><fieldtype=\"bit\" name=\"durable\" type=\"bit\">\n    request a durable exchange\n    <doc>\n      If set when creating a new exchange, the exchange will be marked as\n      durable.  Durable exchanges remain active when a server restarts.\n      Non-durable exchanges (transient exchanges) are purged if\/when a\n      server restarts.\n    <\/doc><ruleimplement=\"MUST\"><test>amq_exchange_24<\/test>\n      The server MUST support both durable and transient exchanges.\n    <\/rule><ruleimplement=\"MUST\">\n      The server MUST ignore the durable field if the exchange already\n      exists.\n    <\/rule><\/field><fieldtype=\"bit\" name=\"auto delete\" type=\"bit\">\n    auto-delete when unused\n    <doc>\n      If set, the exchange is deleted when all queues have finished\n      using it.\n    <\/doc><ruleimplement=\"SHOULD\"><test>amq_exchange_02<\/test>\n      The server SHOULD allow for a reasonable delay between the point\n      when it determines that an exchange is not being used (or no longer\n      used), and the point when it deletes the exchange.  At the least it\n      must allow a client to create an exchange and then bind a queue to\n      it, with a small but non-zero delay between these two actions.\n    <\/rule><ruleimplement=\"MUST\"><test>amq_exchange_25<\/test>\n      The server MUST ignore the auto-delete field if the exchange already\n      exists.\n    <\/rule><\/field><fieldtype=\"bit\" name=\"internal\" type=\"bit\">\n    create internal exchange\n    <doc>\n      If set, the exchange may not be used directly by publishers, but\n      only when bound to other exchanges. Internal exchanges are used to\n      construct wiring that is not visible to applications.\n    <\/doc><\/field><fieldtype=\"bit\" name=\"nowait\" type=\"bit\">\n    do not send a reply method\n    <doc>\n    If set, the server will not respond to the method. The client should\n    not wait for a reply method.  If the server could not complete the\n    method it will raise a channel or connection exception.\n    <\/doc><\/field><fieldtype=\"table\" name=\"arguments\" type=\"table\">\n    arguments for declaration\n    <doc>\n      A set of arguments for the declaration. The syntax and semantics\n      of these arguments depends on the server implementation.  This\n      field is ignored if passive is 1.\n    <\/doc><\/field><\/method><methodname=\"declare-ok\" index=\"11\" synchronous=\"1\">\n  confirms an exchange declaration\n  <doc>\n    This method confirms a Declare method and confirms the name of the\n    exchange, essential for automatically-named exchanges.\n  <\/doc><chassisname=\"client\" implement=\"MUST\"><\/chassis><\/method><methodname=\"delete\" index=\"20\" synchronous=\"1\">\n  delete an exchange\n  <doc>\n    This method deletes an exchange.  When an exchange is deleted all queue\n    bindings on the exchange are cancelled.\n  <\/doc><chassisname=\"server\" implement=\"MUST\"><\/chassis><responsename=\"delete-ok\"><\/response><fieldname=\"ticket\" domain=\"access ticket\"><ruleimplement=\"MUST\">\n      The client MUST provide a valid access ticket giving \"active\"\n      access rights to the exchange's access realm.\n    <\/rule><\/field><fieldname=\"exchange\" domain=\"exchange name\"><ruleimplement=\"MUST\"><test>amq_exchange_11<\/test>\n      The exchange MUST exist. Attempting to delete a non-existing exchange\n      causes a channel exception.\n    <\/rule><assertcheck=\"notnull\"><\/assert><\/field><fieldtype=\"bit\" name=\"if unused\" type=\"bit\">\n    delete only if unused\n    <doc>\n      If set, the server will only delete the exchange if it has no queue\n      bindings. If the exchange has queue bindings the server does not\n      delete it but raises a channel exception instead.\n    <\/doc><ruleimplement=\"SHOULD\"><test>amq_exchange_12<\/test>\n      If set, the server SHOULD delete the exchange but only if it has\n      no queue bindings.\n    <\/rule><ruleimplement=\"SHOULD\"><test>amq_exchange_13<\/test>\n      If set, the server SHOULD raise a channel exception if the exchange is in\n      use.\n    <\/rule><\/field><fieldtype=\"bit\" name=\"nowait\" type=\"bit\">\n    do not send a reply method\n    <doc>\n    If set, the server will not respond to the method. The client should\n    not wait for a reply method.  If the server could not complete the\n    method it will raise a channel or connection exception.\n    <\/doc><\/field><\/method><methodname=\"delete-ok\" index=\"21\" synchronous=\"1\">\n  confirm deletion of an exchange\n  <doc>\n    This method confirms the deletion of an exchange.\n  <\/doc><chassisname=\"client\" implement=\"MUST\"><\/chassis><\/method><\/class><classname=\"queue\" handler=\"channel\" index=\"50\">\n  work with queues\n\n<doc>\n  Queues store and forward messages.  Queues can be configured in the server\n  or created at runtime.  Queues must be attached to at least one exchange\n  in order to receive messages from publishers.\n<\/doc><docname=\"grammar\">\n    queue               = C:DECLARE  S:DECLARE-OK\n                        \/ C:BIND     S:BIND-OK\n                        \/ C:PURGE    S:PURGE-OK\n                        \/ C:DELETE   S:DELETE-OK\n<\/doc><chassisname=\"server\" implement=\"MUST\"><\/chassis><chassisname=\"client\" implement=\"MUST\"><\/chassis><ruleimplement=\"MUST\"><test>amq_queue_33<\/test>\n  A server MUST allow any content class to be sent to any queue, in any\n  mix, and queue and delivery these content classes independently. Note\n  that all methods that fetch content off queues are specific to a given\n  content class.\n<\/rule><methodname=\"declare\" index=\"10\" synchronous=\"1\">\n  declare queue, create if needed\n  <doc>\n    This method creates or checks a queue.  When creating a new queue\n    the client can specify various properties that control the durability\n    of the queue and its contents, and the level of sharing for the queue.\n  <\/doc><ruleimplement=\"MUST\"><test>amq_queue_34<\/test>\n    The server MUST create a default binding for a newly-created queue\n    to the default exchange, which is an exchange of type 'direct'.\n  <\/rule><ruleimplement=\"SHOULD\"><test>amq_queue_35<\/test>\n    The server SHOULD support a minimum of 256 queues per virtual host\n    and ideally, impose no limit except as defined by available resources.\n  <\/rule><chassisname=\"server\" implement=\"MUST\"><\/chassis><responsename=\"declare-ok\"><\/response><fieldname=\"ticket\" domain=\"access ticket\"><doc>\n      When a client defines a new queue, this belongs to the access realm\n      of the ticket used.  All further work done with that queue must be\n      done with an access ticket for the same realm.\n    <\/doc><doc>\n      The client provides a valid access ticket giving \"active\" access\n      to the realm in which the queue exists or will be created, or\n      \"passive\" access if the if-exists flag is set.\n    <\/doc><\/field><fieldname=\"queue\" domain=\"queue name\"><ruleimplement=\"MAY\"><test>amq_queue_10<\/test>\n      The queue name MAY be empty, in which case the server MUST create\n      a new queue with a unique generated name and return this to the\n      client in the Declare-Ok method.\n    <\/rule><ruleimplement=\"MUST\"><test>amq_queue_32<\/test>\n      Queue names starting with \"amq.\" are reserved for predeclared and\n      standardised server queues.  If the queue name starts with \"amq.\"\n      and the passive option is zero, the server MUST raise a connection\n      exception with reply code 403 (access refused).\n    <\/rule><assertvalue=\"^[a-zA-Z0-9-_.:]*$\" check=\"regexp\"><\/assert><\/field><fieldtype=\"bit\" name=\"passive\" type=\"bit\">\n    do not create queue\n    <doc>\n    If set, the server will not create the queue.  The client can use\n    this to check whether a queue exists without modifying the server\n    state.\n    <\/doc><ruleimplement=\"MUST\"><test>amq_queue_05<\/test>\n      If set, and the queue does not already exist, the server MUST\n      respond with a reply code 404 (not found) and raise a channel\n      exception.\n    <\/rule><\/field><fieldtype=\"bit\" name=\"durable\" type=\"bit\">\n    request a durable queue\n    <doc>\n      If set when creating a new queue, the queue will be marked as\n      durable.  Durable queues remain active when a server restarts.\n      Non-durable queues (transient queues) are purged if\/when a\n      server restarts.  Note that durable queues do not necessarily\n      hold persistent messages, although it does not make sense to\n      send persistent messages to a transient queue.\n    <\/doc><ruleimplement=\"MUST\"><test>amq_queue_03<\/test>\n      The server MUST recreate the durable queue after a restart.\n    <\/rule><ruleimplement=\"MUST\"><test>amq_queue_36<\/test>\n      The server MUST support both durable and transient queues.\n    <\/rule><ruleimplement=\"MUST\"><test>amq_queue_37<\/test>\n      The server MUST ignore the durable field if the queue already\n      exists.\n    <\/rule><\/field><fieldtype=\"bit\" name=\"exclusive\" type=\"bit\">\n    request an exclusive queue\n    <doc>\n      Exclusive queues may only be consumed from by the current connection.\n      Setting the 'exclusive' flag always implies 'auto-delete'.\n    <\/doc><ruleimplement=\"MUST\"><test>amq_queue_38<\/test>\n      The server MUST support both exclusive (private) and non-exclusive\n      (shared) queues.\n    <\/rule><ruleimplement=\"MUST\"><test>amq_queue_04<\/test>\n      The server MUST raise a channel exception if 'exclusive' is specified\n      and the queue already exists and is owned by a different connection.\n    <\/rule><\/field><fieldtype=\"bit\" name=\"auto delete\" type=\"bit\">\n    auto-delete queue when unused\n    <doc>\n      If set, the queue is deleted when all consumers have finished\n      using it. Last consumer can be cancelled either explicitly or because\n      its channel is closed. If there was no consumer ever on the queue, it\n      won't be deleted.\n    <\/doc><ruleimplement=\"SHOULD\"><test>amq_queue_02<\/test>\n      The server SHOULD allow for a reasonable delay between the point\n      when it determines that a queue is not being used (or no longer\n      used), and the point when it deletes the queue.  At the least it\n      must allow a client to create a queue and then create a consumer\n      to read from it, with a small but non-zero delay between these\n      two actions.  The server should equally allow for clients that may\n      be disconnected prematurely, and wish to re-consume from the same\n      queue without losing messages.  We would recommend a configurable\n      timeout, with a suitable default value being one minute.\n    <\/rule><ruleimplement=\"MUST\"><test>amq_queue_31<\/test>\n      The server MUST ignore the auto-delete field if the queue already\n      exists.\n    <\/rule><\/field><fieldtype=\"bit\" name=\"nowait\" type=\"bit\">\n    do not send a reply method\n    <doc>\n    If set, the server will not respond to the method. The client should\n    not wait for a reply method.  If the server could not complete the\n    method it will raise a channel or connection exception.\n    <\/doc><\/field><fieldtype=\"table\" name=\"arguments\" type=\"table\">\n    arguments for declaration\n    <doc>\n      A set of arguments for the declaration. The syntax and semantics\n      of these arguments depends on the server implementation.  This\n      field is ignored if passive is 1.\n    <\/doc><\/field><\/method><methodname=\"declare-ok\" index=\"11\" synchronous=\"1\">\n  confirms a queue definition\n  <doc>\n    This method confirms a Declare method and confirms the name of the\n    queue, essential for automatically-named queues.\n  <\/doc><chassisname=\"client\" implement=\"MUST\"><\/chassis><fieldname=\"queue\" domain=\"queue name\"><doc>\n      Reports the name of the queue. If the server generated a queue\n      name, this field contains that name.\n    <\/doc><assertcheck=\"notnull\"><\/assert><\/field><fieldtype=\"long\" name=\"message count\" type=\"long\">\n    number of messages in queue\n    <doc>\n      Reports the number of messages in the queue, which will be zero\n      for newly-created queues.\n    <\/doc><\/field><fieldtype=\"long\" name=\"consumer count\" type=\"long\">\n    number of consumers\n    <doc>\n      Reports the number of active consumers for the queue. Note that\n      consumers can suspend activity (Channel.Flow) in which case they\n      do not appear in this count.\n    <\/doc><\/field><\/method><methodname=\"bind\" index=\"20\" synchronous=\"1\">\n  bind queue to an exchange\n  <doc>\n    This method binds a queue to an exchange.  Until a queue is\n    bound it will not receive any messages.  In a classic messaging\n    model, store-and-forward queues are bound to a dest exchange\n    and subscription queues are bound to a dest_wild exchange.\n  <\/doc><ruleimplement=\"MUST\"><test>amq_queue_25<\/test>\n    A server MUST allow ignore duplicate bindings - that is, two or\n    more bind methods for a specific queue, with identical arguments\n    - without treating these as an error.\n  <\/rule><ruleimplement=\"MUST\"><test>amq_queue_39<\/test>\n    If a bind fails, the server MUST raise a connection exception.\n  <\/rule><ruleimplement=\"MUST\"><test>amq_queue_12<\/test>\n    The server MUST NOT allow a durable queue to bind to a transient\n    exchange. If the client attempts this the server MUST raise a\n    channel exception.\n  <\/rule><ruleimplement=\"SHOULD\"><test>amq_queue_13<\/test>\n    Bindings for durable queues are automatically durable and the\n    server SHOULD restore such bindings after a server restart.\n  <\/rule><ruleimplement=\"MUST\"><test>amq_queue_17<\/test>\n    If the client attempts to an exchange that was declared as internal,\n    the server MUST raise a connection exception with reply code 530\n    (not allowed).\n  <\/rule><ruleimplement=\"SHOULD\"><test>amq_queue_40<\/test>\n    The server SHOULD support at least 4 bindings per queue, and\n    ideally, impose no limit except as defined by available resources.\n  <\/rule><chassisname=\"server\" implement=\"MUST\"><\/chassis><responsename=\"bind-ok\"><\/response><fieldname=\"ticket\" domain=\"access ticket\"><doc>\n      The client provides a valid access ticket giving \"active\"\n      access rights to the queue's access realm.\n    <\/doc><\/field><fieldname=\"queue\" domain=\"queue name\"><doc>\n      Specifies the name of the queue to bind.  If the queue name is\n      empty, refers to the current queue for the channel, which is\n      the last declared queue.\n    <\/doc><docname=\"rule\">\n      If the client did not previously declare a queue, and the queue\n      name in this method is empty, the server MUST raise a connection\n      exception with reply code 530 (not allowed).\n    <\/doc><docname=\"rule\" test=\"amq_queue_26\">\n      If the queue does not exist the server MUST raise a channel exception\n      with reply code 404 (not found).\n    <\/doc><\/field><fieldname=\"exchange\" domain=\"exchange name\">\n          The name of the exchange to bind to.\n          <ruleimplement=\"MUST\"><test>amq_queue_14<\/test>\n      If the exchange does not exist the server MUST raise a channel\n      exception with reply code 404 (not found).\n    <\/rule><\/field><fieldtype=\"shortstr\" name=\"routing key\" type=\"shortstr\">\n     message routing key\n    <doc>\n      Specifies the routing key for the binding.  The routing key is\n      used for routing messages depending on the exchange configuration.\n      Not all exchanges use a routing key - refer to the specific\n      exchange documentation.  If the routing key is empty and the queue\n      name is empty, the routing key will be the current queue for the\n      channel, which is the last declared queue.\n    <\/doc><\/field><fieldtype=\"bit\" name=\"nowait\" type=\"bit\">\n    do not send a reply method\n    <doc>\n    If set, the server will not respond to the method. The client should\n    not wait for a reply method.  If the server could not complete the\n    method it will raise a channel or connection exception.\n    <\/doc><\/field><fieldtype=\"table\" name=\"arguments\" type=\"table\">\n    arguments for binding\n    <doc>\n      A set of arguments for the binding.  The syntax and semantics of\n      these arguments depends on the exchange class.\n    <\/doc><\/field><\/method><methodname=\"bind-ok\" index=\"21\" synchronous=\"1\">\n  confirm bind successful\n  <doc>\n    This method confirms that the bind was successful.\n  <\/doc><chassisname=\"client\" implement=\"MUST\"><\/chassis><\/method><methodname=\"purge\" index=\"30\" synchronous=\"1\">\n  purge a queue\n  <doc>\n    This method removes all messages from a queue.  It does not cancel\n    consumers.  Purged messages are deleted without any formal \"undo\"\n    mechanism.\n  <\/doc><ruleimplement=\"MUST\"><test>amq_queue_15<\/test>\n    A call to purge MUST result in an empty queue.\n  <\/rule><ruleimplement=\"MUST\"><test>amq_queue_41<\/test>\n    On transacted channels the server MUST not purge messages that have\n    already been sent to a client but not yet acknowledged.\n  <\/rule><ruleimplement=\"MAY\"><test>amq_queue_42<\/test>\n    The server MAY implement a purge queue or log that allows system\n    administrators to recover accidentally-purged messages.  The server\n    SHOULD NOT keep purged messages in the same storage spaces as the\n    live messages since the volumes of purged messages may get very\n    large.\n  <\/rule><chassisname=\"server\" implement=\"MUST\"><\/chassis><responsename=\"purge-ok\"><\/response><fieldname=\"ticket\" domain=\"access ticket\"><doc>\n      The access ticket must be for the access realm that holds the\n      queue.\n    <\/doc><ruleimplement=\"MUST\">\n      The client MUST provide a valid access ticket giving \"read\" access\n      rights to the queue's access realm.  Note that purging a queue is\n      equivalent to reading all messages and discarding them.\n    <\/rule><\/field><fieldname=\"queue\" domain=\"queue name\"><doc>\n      Specifies the name of the queue to purge.  If the queue name is\n      empty, refers to the current queue for the channel, which is\n      the last declared queue.\n    <\/doc><docname=\"rule\">\n      If the client did not previously declare a queue, and the queue\n      name in this method is empty, the server MUST raise a connection\n      exception with reply code 530 (not allowed).\n    <\/doc><docname=\"rule\" test=\"amq_queue_16\">\n      The queue must exist. Attempting to purge a non-existing queue\n      causes a channel exception.\n    <\/doc><\/field><fieldtype=\"bit\" name=\"nowait\" type=\"bit\">\n    do not send a reply method\n    <doc>\n    If set, the server will not respond to the method. The client should\n    not wait for a reply method.  If the server could not complete the\n    method it will raise a channel or connection exception.\n    <\/doc><\/field><\/method><methodname=\"purge-ok\" index=\"31\" synchronous=\"1\">\n  confirms a queue purge\n  <doc>\n    This method confirms the purge of a queue.\n  <\/doc><chassisname=\"client\" implement=\"MUST\"><\/chassis><fieldtype=\"long\" name=\"message count\" type=\"long\">\n    number of messages purged\n    <doc>\n      Reports the number of messages purged.\n    <\/doc><\/field><\/method><methodname=\"delete\" index=\"40\" synchronous=\"1\">\n  delete a queue\n  <doc>\n    This method deletes a queue.  When a queue is deleted any pending\n    messages are sent to a dead-letter queue if this is defined in the\n    server configuration, and all consumers on the queue are cancelled.\n  <\/doc><ruleimplement=\"SHOULD\"><test>amq_queue_43<\/test>\n    The server SHOULD use a dead-letter queue to hold messages that\n    were pending on a deleted queue, and MAY provide facilities for\n    a system administrator to move these messages back to an active\n    queue.\n  <\/rule><chassisname=\"server\" implement=\"MUST\"><\/chassis><responsename=\"delete-ok\"><\/response><fieldname=\"ticket\" domain=\"access ticket\"><doc>\n      The client provides a valid access ticket giving \"active\"\n      access rights to the queue's access realm.\n    <\/doc><\/field><fieldname=\"queue\" domain=\"queue name\"><doc>\n      Specifies the name of the queue to delete. If the queue name is\n      empty, refers to the current queue for the channel, which is the\n      last declared queue.\n    <\/doc><docname=\"rule\">\n      If the client did not previously declare a queue, and the queue\n      name in this method is empty, the server MUST raise a connection\n      exception with reply code 530 (not allowed).\n    <\/doc><docname=\"rule\" test=\"amq_queue_21\">\n      The queue must exist. Attempting to delete a non-existing queue\n      causes a channel exception.\n    <\/doc><\/field><fieldtype=\"bit\" name=\"if unused\" type=\"bit\">\n    delete only if unused\n    <doc>\n      If set, the server will only delete the queue if it has no\n      consumers. If the queue has consumers the server does does not\n      delete it but raises a channel exception instead.\n    <\/doc><ruleimplement=\"MUST\"><test>amq_queue_29<\/test><test>amq_queue_30<\/test>\n      The server MUST respect the if-unused flag when deleting a queue.\n    <\/rule><\/field><fieldtype=\"bit\" name=\"if empty\" type=\"bit\">\n    delete only if empty\n\t<test>amq_queue_27<\/test><doc>\n      If set, the server will only delete the queue if it has no\n      messages. If the queue is not empty the server raises a channel\n      exception.\n    <\/doc><\/field><fieldtype=\"bit\" name=\"nowait\" type=\"bit\">\n    do not send a reply method\n    <doc>\n    If set, the server will not respond to the method. The client should\n    not wait for a reply method.  If the server could not complete the\n    method it will raise a channel or connection exception.\n    <\/doc><\/field><\/method><methodname=\"delete-ok\" index=\"41\" synchronous=\"1\">\n  confirm deletion of a queue\n  <doc>\n    This method confirms the deletion of a queue.\n  <\/doc><chassisname=\"client\" implement=\"MUST\"><\/chassis><fieldtype=\"long\" name=\"message count\" type=\"long\">\n    number of messages purged\n    <doc>\n      Reports the number of messages purged.\n    <\/doc><\/field><\/method><\/class><classname=\"basic\" handler=\"channel\" index=\"60\">\n  work with basic content\n<doc>\n  The Basic class provides methods that support an industry-standard\n  messaging model.\n<\/doc><docname=\"grammar\">\n    basic               = C:QOS S:QOS-OK\n                        \/ C:CONSUME S:CONSUME-OK\n                        \/ C:CANCEL S:CANCEL-OK\n                        \/ C:PUBLISH content\n                        \/ S:RETURN content\n                        \/ S:DELIVER content\n                        \/ C:GET ( S:GET-OK content \/ S:GET-EMPTY )\n                        \/ C:ACK\n                        \/ C:REJECT\n<\/doc><chassisname=\"server\" implement=\"MUST\"><\/chassis><chassisname=\"client\" implement=\"MAY\"><\/chassis><docname=\"rule\" test=\"amq_basic_08\">\n  The server SHOULD respect the persistent property of basic messages\n  and SHOULD make a best-effort to hold persistent basic messages on a\n  reliable storage mechanism.\n<\/doc><docname=\"rule\" test=\"amq_basic_09\">\n  The server MUST NOT discard a persistent basic message in case of a\n  queue overflow. The server MAY use the Channel.Flow method to slow\n  or stop a basic message publisher when necessary.\n<\/doc><docname=\"rule\" test=\"amq_basic_10\">\n  The server MAY overflow non-persistent basic messages to persistent\n  storage and MAY discard or dead-letter non-persistent basic messages\n  on a priority basis if the queue size exceeds some configured limit.\n<\/doc><docname=\"rule\" test=\"amq_basic_11\">\n  The server MUST implement at least 2 priority levels for basic\n  messages, where priorities 0-4 and 5-9 are treated as two distinct\n  levels. The server MAY implement up to 10 priority levels.\n<\/doc><docname=\"rule\" test=\"amq_basic_12\">\n  The server MUST deliver messages of the same priority in order\n  irrespective of their individual persistence.\n<\/doc><docname=\"rule\" test=\"amq_basic_13\">\n  The server MUST support both automatic and explicit acknowledgements\n  on Basic content.\n<\/doc><fieldtype=\"shortstr\" name=\"content type\" type=\"shortstr\">\n    MIME content type\n<\/field><fieldtype=\"shortstr\" name=\"content encoding\" type=\"shortstr\">\n    MIME content encoding\n<\/field><fieldtype=\"table\" name=\"headers\" type=\"table\">\n    Message header field table\n<\/field><fieldtype=\"octet\" name=\"delivery mode\" type=\"octet\">\n    Non-persistent (1) or persistent (2)\n<\/field><fieldtype=\"octet\" name=\"priority\" type=\"octet\">\n    The message priority, 0 to 9\n<\/field><fieldtype=\"shortstr\" name=\"correlation id\" type=\"shortstr\">\n    The application correlation identifier\n<\/field><fieldtype=\"shortstr\" name=\"reply to\" type=\"shortstr\">\n    The destination to reply to\n<\/field><fieldtype=\"shortstr\" name=\"expiration\" type=\"shortstr\">\n    Message expiration specification\n<\/field><fieldtype=\"shortstr\" name=\"message id\" type=\"shortstr\">\n    The application message identifier\n<\/field><fieldtype=\"timestamp\" name=\"timestamp\" type=\"timestamp\">\n    The message timestamp\n<\/field><fieldtype=\"shortstr\" name=\"type\" type=\"shortstr\">\n    The message type name\n<\/field><fieldtype=\"shortstr\" name=\"user id\" type=\"shortstr\">\n    The creating user id\n<\/field><fieldtype=\"shortstr\" name=\"app id\" type=\"shortstr\">\n    The creating application id\n<\/field><fieldtype=\"shortstr\" name=\"cluster id\" type=\"shortstr\">\n    Intra-cluster routing identifier\n<\/field><methodname=\"qos\" index=\"10\" synchronous=\"1\">\n  specify quality of service\n  <doc>\n    This method requests a specific quality of service.  The QoS can\n    be specified for the current channel or for all channels on the\n    connection.  The particular properties and semantics of a qos method\n    always depend on the content class semantics.  Though the qos method\n    could in principle apply to both peers, it is currently meaningful\n    only for the server.\n  <\/doc><chassisname=\"server\" implement=\"MUST\"><\/chassis><responsename=\"qos-ok\"><\/response><fieldtype=\"long\" name=\"prefetch size\" type=\"long\">\n    prefetch window in octets\n    <doc>\n      The client can request that messages be sent in advance so that\n      when the client finishes processing a message, the following\n      message is already held locally, rather than needing to be sent\n      down the channel.  Prefetching gives a performance improvement.\n      This field specifies the prefetch window size in octets.  The\n      server will send a message in advance if it is equal to or\n      smaller in size than the available prefetch size (and also falls\n      into other prefetch limits). May be set to zero, meaning \"no\n      specific limit\", although other prefetch limits may still apply.\n      The prefetch-size is ignored if the no-ack option is set.\n    <\/doc><docname=\"rule\" test=\"amq_basic_17\">\n      The server MUST ignore this setting when the client is not\n      processing any messages - i.e. the prefetch size does not limit\n      the transfer of single messages to a client, only the sending in\n      advance of more messages while the client still has one or more\n      unacknowledged messages.\n   <\/doc><\/field><fieldtype=\"short\" name=\"prefetch count\" type=\"short\">\n    prefetch window in messages\n    <doc>\n      Specifies a prefetch window in terms of whole messages.  This\n      field may be used in combination with the prefetch-size field;\n      a message will only be sent in advance if both prefetch windows\n      (and those at the channel and connection level) allow it.\n      The prefetch-count is ignored if the no-ack option is set.\n    <\/doc><docname=\"rule\" test=\"amq_basic_18\">\n      The server MAY send less data in advance than allowed by the\n      client's specified prefetch windows but it MUST NOT send more.\n    <\/doc><\/field><fieldtype=\"bit\" name=\"global\" type=\"bit\">\n    apply to entire connection\n    <doc>\n      By default the QoS settings apply to the current channel only.  If\n      this field is set, they are applied to the entire connection.\n    <\/doc><\/field><\/method><methodname=\"qos-ok\" index=\"11\" synchronous=\"1\">\n  confirm the requested qos\n  <doc>\n    This method tells the client that the requested QoS levels could\n    be handled by the server.  The requested QoS applies to all active\n    consumers until a new QoS is defined.\n  <\/doc><chassisname=\"client\" implement=\"MUST\"><\/chassis><\/method><methodname=\"consume\" index=\"20\" synchronous=\"1\">\n  start a queue consumer\n  <doc>\n    This method asks the server to start a \"consumer\", which is a\n    transient request for messages from a specific queue. Consumers\n    last as long as the channel they were created on, or until the\n    client cancels them.\n  <\/doc><docname=\"rule\" test=\"amq_basic_01\">\n    The server SHOULD support at least 16 consumers per queue, unless\n    the queue was declared as private, and ideally, impose no limit\n    except as defined by available resources.\n  <\/doc><chassisname=\"server\" implement=\"MUST\"><\/chassis><responsename=\"consume-ok\"><\/response><fieldname=\"ticket\" domain=\"access ticket\"><docname=\"rule\">\n      The client MUST provide a valid access ticket giving \"read\" access\n      rights to the realm for the queue.\n    <\/doc><\/field><fieldname=\"queue\" domain=\"queue name\"><doc>\n      Specifies the name of the queue to consume from.  If the queue name\n      is null, refers to the current queue for the channel, which is the\n      last declared queue.\n    <\/doc><docname=\"rule\">\n      If the client did not previously declare a queue, and the queue name\n      in this method is empty, the server MUST raise a connection exception\n      with reply code 530 (not allowed).\n    <\/doc><\/field><fieldname=\"consumer tag\" domain=\"consumer tag\"><doc>\n      Specifies the identifier for the consumer. The consumer tag is\n      local to a connection, so two clients can use the same consumer\n      tags. If this field is empty the server will generate a unique\n      tag.\n    <\/doc><docname=\"rule\" test=\"todo\">\n      The tag MUST NOT refer to an existing consumer. If the client\n      attempts to create two consumers with the same non-empty tag\n      the server MUST raise a connection exception with reply code\n      530 (not allowed).\n    <\/doc><\/field><fieldname=\"no local\" domain=\"no local\"><\/field><fieldname=\"no ack\" domain=\"no ack\"><\/field><fieldtype=\"bit\" name=\"exclusive\" type=\"bit\">\n    request exclusive access\n    <doc>\n      Request exclusive consumer access, meaning only this consumer can\n      access the queue.\n    <\/doc><docname=\"rule\" test=\"amq_basic_02\">\n      If the server cannot grant exclusive access to the queue when asked,\n      - because there are other consumers active - it MUST raise a channel\n      exception with return code 403 (access refused).\n    <\/doc><\/field><fieldtype=\"bit\" name=\"nowait\" type=\"bit\">\n    do not send a reply method\n    <doc>\n    If set, the server will not respond to the method. The client should\n    not wait for a reply method.  If the server could not complete the\n    method it will raise a channel or connection exception.\n    <\/doc><\/field><\/method><methodname=\"consume-ok\" index=\"21\" synchronous=\"1\">\n  confirm a new consumer\n  <doc>\n    The server provides the client with a consumer tag, which is used\n    by the client for methods called on the consumer at a later stage.\n  <\/doc><chassisname=\"client\" implement=\"MUST\"><\/chassis><fieldname=\"consumer tag\" domain=\"consumer tag\"><doc>\n      Holds the consumer tag specified by the client or provided by\n      the server.\n    <\/doc><\/field><\/method><methodname=\"cancel\" index=\"30\" synchronous=\"1\">\n  end a queue consumer\n  <doctest=\"amq_basic_04\">\n    This method cancels a consumer. This does not affect already\n    delivered messages, but it does mean the server will not send any\n    more messages for that consumer.  The client may receive an\n    abitrary number of messages in between sending the cancel method\n    and receiving the cancel-ok reply.\n  <\/doc><docname=\"rule\" test=\"todo\">\n    If the queue no longer exists when the client sends a cancel command,\n    or the consumer has been cancelled for other reasons, this command\n    has no effect.\n  <\/doc><chassisname=\"server\" implement=\"MUST\"><\/chassis><responsename=\"cancel-ok\"><\/response><fieldname=\"consumer tag\" domain=\"consumer tag\"><\/field><fieldtype=\"bit\" name=\"nowait\" type=\"bit\">\n    do not send a reply method\n    <doc>\n    If set, the server will not respond to the method. The client should\n    not wait for a reply method.  If the server could not complete the\n    method it will raise a channel or connection exception.\n    <\/doc><\/field><\/method><methodname=\"cancel-ok\" index=\"31\" synchronous=\"1\">\n  confirm a cancelled consumer\n  <doc>\n    This method confirms that the cancellation was completed.\n  <\/doc><chassisname=\"client\" implement=\"MUST\"><\/chassis><fieldname=\"consumer tag\" domain=\"consumer tag\"><\/field><\/method><methodname=\"publish\" index=\"40\" content=\"1\">\n  publish a message\n  <doc>\n    This method publishes a message to a specific exchange. The message\n    will be routed to queues as defined by the exchange configuration\n    and distributed to any active consumers when the transaction, if any,\n    is committed.\n  <\/doc><chassisname=\"server\" implement=\"MUST\"><\/chassis><fieldname=\"ticket\" domain=\"access ticket\"><docname=\"rule\">\n      The client MUST provide a valid access ticket giving \"write\"\n      access rights to the access realm for the exchange.\n    <\/doc><\/field><fieldname=\"exchange\" domain=\"exchange name\"><doc>\n      Specifies the name of the exchange to publish to.  The exchange\n      name can be empty, meaning the default exchange.  If the exchange\n      name is specified, and that exchange does not exist, the server\n      will raise a channel exception.\n    <\/doc><docname=\"rule\" test=\"amq_basic_06\">\n      The server MUST accept a blank exchange name to mean the default\n      exchange.\n    <\/doc><docname=\"rule\" test=\"amq_basic_14\">\n      If the exchange was declared as an internal exchange, the server\n      MUST raise a channel exception with a reply code 403 (access\n      refused).\n    <\/doc><docname=\"rule\" test=\"amq_basic_15\">\n      The exchange MAY refuse basic content in which case it MUST raise\n      a channel exception with reply code 540 (not implemented).\n    <\/doc><\/field><fieldtype=\"shortstr\" name=\"routing key\" type=\"shortstr\">\n     Message routing key\n    <doc>\n      Specifies the routing key for the message.  The routing key is\n      used for routing messages depending on the exchange configuration.\n    <\/doc><\/field><fieldtype=\"bit\" name=\"mandatory\" type=\"bit\">\n    indicate mandatory routing\n    <doc>\n      This flag tells the server how to react if the message cannot be\n      routed to a queue.  If this flag is set, the server will return an\n      unroutable message with a Return method.  If this flag is zero, the\n      server silently drops the message.\n    <\/doc><docname=\"rule\" test=\"amq_basic_07\">\n      The server SHOULD implement the mandatory flag.\n    <\/doc><\/field><fieldtype=\"bit\" name=\"immediate\" type=\"bit\">\n    request immediate delivery\n    <doc>\n      This flag tells the server how to react if the message cannot be\n      routed to a queue consumer immediately.  If this flag is set, the\n      server will return an undeliverable message with a Return method.\n      If this flag is zero, the server will queue the message, but with\n      no guarantee that it will ever be consumed.\n    <\/doc><docname=\"rule\" test=\"amq_basic_16\">\n      The server SHOULD implement the immediate flag.\n    <\/doc><\/field><\/method><methodname=\"return\" index=\"50\" content=\"1\">\n  return a failed message\n  <doc>\n    This method returns an undeliverable message that was published\n    with the \"immediate\" flag set, or an unroutable message published\n    with the \"mandatory\" flag set. The reply code and text provide\n    information about the reason that the message was undeliverable.\n  <\/doc><chassisname=\"client\" implement=\"MUST\"><\/chassis><fieldname=\"reply code\" domain=\"reply code\"><\/field><fieldname=\"reply text\" domain=\"reply text\"><\/field><fieldname=\"exchange\" domain=\"exchange name\"><doc>\n      Specifies the name of the exchange that the message was\n      originally published to.\n    <\/doc><\/field><fieldtype=\"shortstr\" name=\"routing key\" type=\"shortstr\">\n     Message routing key\n    <doc>\n      Specifies the routing key name specified when the message was\n      published.\n    <\/doc><\/field><\/method><methodname=\"deliver\" index=\"60\" content=\"1\">\n  notify the client of a consumer message\n  <doc>\n    This method delivers a message to the client, via a consumer.  In\n    the asynchronous message delivery model, the client starts a\n    consumer using the Consume method, then the server responds with\n    Deliver methods as and when messages arrive for that consumer.\n  <\/doc><docname=\"rule\" test=\"amq_basic_19\">\n    The server SHOULD track the number of times a message has been\n    delivered to clients and when a message is redelivered a certain\n    number of times - e.g. 5 times - without being acknowledged, the\n    server SHOULD consider the message to be unprocessable (possibly\n    causing client applications to abort), and move the message to a\n    dead letter queue.\n  <\/doc><chassisname=\"client\" implement=\"MUST\"><\/chassis><fieldname=\"consumer tag\" domain=\"consumer tag\"><\/field><fieldname=\"delivery tag\" domain=\"delivery tag\"><\/field><fieldname=\"redelivered\" domain=\"redelivered\"><\/field><fieldname=\"exchange\" domain=\"exchange name\"><doc>\n      Specifies the name of the exchange that the message was\n      originally published to.\n    <\/doc><\/field><fieldtype=\"shortstr\" name=\"routing key\" type=\"shortstr\">\n     Message routing key\n    <doc>\n      Specifies the routing key name specified when the message was\n      published.\n    <\/doc><\/field><\/method><methodname=\"get\" index=\"70\" synchronous=\"1\">\n  direct access to a queue\n  <doc>\n    This method provides a direct access to the messages in a queue\n    using a synchronous dialogue that is designed for specific types of\n    application where synchronous functionality is more important than\n    performance.\n  <\/doc><responsename=\"get-ok\"><\/response><responsename=\"get-empty\"><\/response><chassisname=\"server\" implement=\"MUST\"><\/chassis><fieldname=\"ticket\" domain=\"access ticket\"><docname=\"rule\">\n      The client MUST provide a valid access ticket giving \"read\"\n      access rights to the realm for the queue.\n    <\/doc><\/field><fieldname=\"queue\" domain=\"queue name\"><doc>\n      Specifies the name of the queue to consume from.  If the queue name\n      is null, refers to the current queue for the channel, which is the\n      last declared queue.\n    <\/doc><docname=\"rule\">\n      If the client did not previously declare a queue, and the queue name\n      in this method is empty, the server MUST raise a connection exception\n      with reply code 530 (not allowed).\n    <\/doc><\/field><fieldname=\"no ack\" domain=\"no ack\"><\/field><\/method><methodname=\"get-ok\" index=\"71\" content=\"1\" synchronous=\"1\">\n  provide client with a message\n  <doc>\n    This method delivers a message to the client following a get\n    method.  A message delivered by 'get-ok' must be acknowledged\n    unless the no-ack option was set in the get method.\n  <\/doc><chassisname=\"client\" implement=\"MAY\"><\/chassis><fieldname=\"delivery tag\" domain=\"delivery tag\"><\/field><fieldname=\"redelivered\" domain=\"redelivered\"><\/field><fieldname=\"exchange\" domain=\"exchange name\"><doc>\n      Specifies the name of the exchange that the message was originally\n      published to.  If empty, the message was published to the default\n      exchange.\n    <\/doc><\/field><fieldtype=\"shortstr\" name=\"routing key\" type=\"shortstr\">\n     Message routing key\n    <doc>\n      Specifies the routing key name specified when the message was\n      published.\n    <\/doc><\/field><fieldtype=\"long\" name=\"message count\" type=\"long\">\n    number of messages pending\n    <doc>\n      This field reports the number of messages pending on the queue,\n      excluding the message being delivered.  Note that this figure is\n      indicative, not reliable, and can change arbitrarily as messages\n      are added to the queue and removed by other clients.\n    <\/doc><\/field><\/method><methodname=\"get-empty\" index=\"72\" synchronous=\"1\">\n  indicate no messages available\n  <doc>\n    This method tells the client that the queue has no messages\n    available for the client.\n  <\/doc><chassisname=\"client\" implement=\"MAY\"><\/chassis><fieldtype=\"shortstr\" name=\"cluster id\" type=\"shortstr\">\n     Cluster id\n    <doc>\n      For use by cluster applications, should not be used by\n      client applications.\n    <\/doc><\/field><\/method><methodname=\"ack\" index=\"80\">\n  acknowledge one or more messages\n  <doc>\n    This method acknowledges one or more messages delivered via the\n    Deliver or Get-Ok methods.  The client can ask to confirm a\n    single message or a set of messages up to and including a specific\n    message.\n  <\/doc><chassisname=\"server\" implement=\"MUST\"><\/chassis><fieldname=\"delivery tag\" domain=\"delivery tag\"><\/field><fieldtype=\"bit\" name=\"multiple\" type=\"bit\">\n    acknowledge multiple messages\n    <doc>\n      If set to 1, the delivery tag is treated as \"up to and including\",\n      so that the client can acknowledge multiple messages with a single\n      method.  If set to zero, the delivery tag refers to a single\n      message.  If the multiple field is 1, and the delivery tag is zero,\n      tells the server to acknowledge all outstanding mesages.\n    <\/doc><docname=\"rule\" test=\"amq_basic_20\">\n      The server MUST validate that a non-zero delivery-tag refers to an\n      delivered message, and raise a channel exception if this is not the\n      case.\n    <\/doc><\/field><\/method><methodname=\"reject\" index=\"90\">\n  reject an incoming message\n  <doc>\n    This method allows a client to reject a message.  It can be used to\n    interrupt and cancel large incoming messages, or return untreatable\n    messages to their original queue.\n  <\/doc><docname=\"rule\" test=\"amq_basic_21\">\n    The server SHOULD be capable of accepting and process the Reject\n    method while sending message content with a Deliver or Get-Ok\n    method.  I.e. the server should read and process incoming methods\n    while sending output frames.  To cancel a partially-send content,\n    the server sends a content body frame of size 1 (i.e. with no data\n    except the frame-end octet).\n  <\/doc><docname=\"rule\" test=\"amq_basic_22\">\n    The server SHOULD interpret this method as meaning that the client\n    is unable to process the message at this time.\n  <\/doc><docname=\"rule\">\n    A client MUST NOT use this method as a means of selecting messages\n    to process.  A rejected message MAY be discarded or dead-lettered,\n    not necessarily passed to another client.\n  <\/doc><chassisname=\"server\" implement=\"MUST\"><\/chassis><fieldname=\"delivery tag\" domain=\"delivery tag\"><\/field><fieldtype=\"bit\" name=\"requeue\" type=\"bit\">\n    requeue the message\n    <doc>\n      If this field is zero, the message will be discarded.  If this bit\n      is 1, the server will attempt to requeue the message.\n    <\/doc><docname=\"rule\" test=\"amq_basic_23\">\n      The server MUST NOT deliver the message to the same client within\n      the context of the current channel.  The recommended strategy is\n      to attempt to deliver the message to an alternative consumer, and\n      if that is not possible, to move the message to a dead-letter\n      queue.  The server MAY use more sophisticated tracking to hold\n      the message on the queue and redeliver it to the same client at\n      a later stage.\n    <\/doc><\/field><\/method><methodname=\"recover\" index=\"100\">\n  redeliver unacknowledged messages. This method is only allowed on non-transacted channels.\n  <doc>\n    This method asks the broker to redeliver all unacknowledged messages on a\n    specifieid channel. Zero or more messages may be redelivered.\n  <\/doc><chassisname=\"server\" implement=\"MUST\"><\/chassis><fieldtype=\"bit\" name=\"requeue\" type=\"bit\">\n    requeue the message\n    <doc>\n      If this field is zero, the message will be redelivered to the original recipient.  If this bit\n      is 1, the server will attempt to requeue the message, potentially then delivering it to an\n      alternative subscriber.\n    <\/doc><\/field><docname=\"rule\">\n      The server MUST set the redelivered flag on all messages that are resent.\n    <\/doc><docname=\"rule\">\n    The server MUST raise a channel exception if this is called on a transacted channel.\n    <\/doc><\/method><\/class><classname=\"file\" handler=\"channel\" index=\"70\">\n  work with file content\n<doc>\n  The file class provides methods that support reliable file transfer.\n  File messages have a specific set of properties that are required for\n  interoperability with file transfer applications. File messages and\n  acknowledgements are subject to channel transactions.  Note that the\n  file class does not provide message browsing methods; these are not\n  compatible with the staging model.  Applications that need browsable\n  file transfer should use Basic content and the Basic class.\n<\/doc><docname=\"grammar\">\n    file                = C:QOS S:QOS-OK\n                        \/ C:CONSUME S:CONSUME-OK\n                        \/ C:CANCEL S:CANCEL-OK\n                        \/ C:OPEN S:OPEN-OK C:STAGE content\n                        \/ S:OPEN C:OPEN-OK S:STAGE content\n                        \/ C:PUBLISH\n                        \/ S:DELIVER\n                        \/ S:RETURN\n                        \/ C:ACK\n                        \/ C:REJECT\n<\/doc><chassisname=\"server\" implement=\"MAY\"><\/chassis><chassisname=\"client\" implement=\"MAY\"><\/chassis><docname=\"rule\">\n  The server MUST make a best-effort to hold file messages on a\n  reliable storage mechanism.\n<\/doc><docname=\"rule\">\n  The server MUST NOT discard a file message in case of a queue\n  overflow. The server MUST use the Channel.Flow method to slow or stop\n  a file message publisher when necessary.\n<\/doc><docname=\"rule\">\n  The server MUST implement at least 2 priority levels for file\n  messages, where priorities 0-4 and 5-9 are treated as two distinct\n  levels. The server MAY implement up to 10 priority levels.\n<\/doc><docname=\"rule\">\n  The server MUST support both automatic and explicit acknowledgements\n  on file content.\n<\/doc><fieldtype=\"shortstr\" name=\"content type\" type=\"shortstr\">\n    MIME content type\n<\/field><fieldtype=\"shortstr\" name=\"content encoding\" type=\"shortstr\">\n    MIME content encoding\n<\/field><fieldtype=\"table\" name=\"headers\" type=\"table\">\n    Message header field table\n<\/field><fieldtype=\"octet\" name=\"priority\" type=\"octet\">\n    The message priority, 0 to 9\n<\/field><fieldtype=\"shortstr\" name=\"reply to\" type=\"shortstr\">\n    The destination to reply to\n<\/field><fieldtype=\"shortstr\" name=\"message id\" type=\"shortstr\">\n    The application message identifier\n<\/field><fieldtype=\"shortstr\" name=\"filename\" type=\"shortstr\">\n    The message filename\n<\/field><fieldtype=\"timestamp\" name=\"timestamp\" type=\"timestamp\">\n    The message timestamp\n<\/field><fieldtype=\"shortstr\" name=\"cluster id\" type=\"shortstr\">\n    Intra-cluster routing identifier\n<\/field><methodname=\"qos\" index=\"10\" synchronous=\"1\">\n  specify quality of service\n  <doc>\n    This method requests a specific quality of service.  The QoS can\n    be specified for the current channel or for all channels on the\n    connection.  The particular properties and semantics of a qos method\n    always depend on the content class semantics.  Though the qos method\n    could in principle apply to both peers, it is currently meaningful\n    only for the server.\n  <\/doc><chassisname=\"server\" implement=\"MUST\"><\/chassis><responsename=\"qos-ok\"><\/response><fieldtype=\"long\" name=\"prefetch size\" type=\"long\">\n    prefetch window in octets\n    <doc>\n      The client can request that messages be sent in advance so that\n      when the client finishes processing a message, the following\n      message is already held locally, rather than needing to be sent\n      down the channel.  Prefetching gives a performance improvement.\n      This field specifies the prefetch window size in octets. May be\n      set to zero, meaning \"no specific limit\".  Note that other\n      prefetch limits may still apply. The prefetch-size is ignored\n      if the no-ack option is set.\n    <\/doc><\/field><fieldtype=\"short\" name=\"prefetch count\" type=\"short\">\n    prefetch window in messages\n    <doc>\n      Specifies a prefetch window in terms of whole messages.  This\n      is compatible with some file API implementations.  This field\n      may be used in combination with the prefetch-size field; a\n      message will only be sent in advance if both prefetch windows\n      (and those at the channel and connection level) allow it.\n      The prefetch-count is ignored if the no-ack option is set.\n    <\/doc><docname=\"rule\">\n      The server MAY send less data in advance than allowed by the\n      client's specified prefetch windows but it MUST NOT send more.\n    <\/doc><\/field><fieldtype=\"bit\" name=\"global\" type=\"bit\">\n    apply to entire connection\n    <doc>\n      By default the QoS settings apply to the current channel only.  If\n      this field is set, they are applied to the entire connection.\n    <\/doc><\/field><\/method><methodname=\"qos-ok\" index=\"11\" synchronous=\"1\">\n  confirm the requested qos\n  <doc>\n    This method tells the client that the requested QoS levels could\n    be handled by the server.  The requested QoS applies to all active\n    consumers until a new QoS is defined.\n  <\/doc><chassisname=\"client\" implement=\"MUST\"><\/chassis><\/method><methodname=\"consume\" index=\"20\" synchronous=\"1\">\n  start a queue consumer\n  <doc>\n    This method asks the server to start a \"consumer\", which is a\n    transient request for messages from a specific queue. Consumers\n    last as long as the channel they were created on, or until the\n    client cancels them.\n  <\/doc><docname=\"rule\">\n    The server SHOULD support at least 16 consumers per queue, unless\n    the queue was declared as private, and ideally, impose no limit\n    except as defined by available resources.\n  <\/doc><chassisname=\"server\" implement=\"MUST\"><\/chassis><responsename=\"consume-ok\"><\/response><fieldname=\"ticket\" domain=\"access ticket\"><docname=\"rule\">\n      The client MUST provide a valid access ticket giving \"read\" access\n      rights to the realm for the queue.\n    <\/doc><\/field><fieldname=\"queue\" domain=\"queue name\"><doc>\n      Specifies the name of the queue to consume from.  If the queue name\n      is null, refers to the current queue for the channel, which is the\n      last declared queue.\n    <\/doc><docname=\"rule\">\n      If the client did not previously declare a queue, and the queue name\n      in this method is empty, the server MUST raise a connection exception\n      with reply code 530 (not allowed).\n    <\/doc><\/field><fieldname=\"consumer tag\" domain=\"consumer tag\"><doc>\n      Specifies the identifier for the consumer. The consumer tag is\n      local to a connection, so two clients can use the same consumer\n      tags. If this field is empty the server will generate a unique\n      tag.\n    <\/doc><docname=\"rule\" test=\"todo\">\n      The tag MUST NOT refer to an existing consumer. If the client\n      attempts to create two consumers with the same non-empty tag\n      the server MUST raise a connection exception with reply code\n      530 (not allowed).\n    <\/doc><\/field><fieldname=\"no local\" domain=\"no local\"><\/field><fieldname=\"no ack\" domain=\"no ack\"><\/field><fieldtype=\"bit\" name=\"exclusive\" type=\"bit\">\n    request exclusive access\n    <doc>\n      Request exclusive consumer access, meaning only this consumer can\n      access the queue.\n    <\/doc><docname=\"rule\" test=\"amq_file_00\">\n      If the server cannot grant exclusive access to the queue when asked,\n      - because there are other consumers active - it MUST raise a channel\n      exception with return code 405 (resource locked).\n    <\/doc><\/field><fieldtype=\"bit\" name=\"nowait\" type=\"bit\">\n    do not send a reply method\n    <doc>\n    If set, the server will not respond to the method. The client should\n    not wait for a reply method.  If the server could not complete the\n    method it will raise a channel or connection exception.\n    <\/doc><\/field><\/method><methodname=\"consume-ok\" index=\"21\" synchronous=\"1\">\n  confirm a new consumer\n  <doc>\n    This method provides the client with a consumer tag which it MUST\n    use in methods that work with the consumer.\n  <\/doc><chassisname=\"client\" implement=\"MUST\"><\/chassis><fieldname=\"consumer tag\" domain=\"consumer tag\"><doc>\n      Holds the consumer tag specified by the client or provided by\n      the server.\n    <\/doc><\/field><\/method><methodname=\"cancel\" index=\"30\" synchronous=\"1\">\n  end a queue consumer\n  <doc>\n    This method cancels a consumer. This does not affect already\n    delivered messages, but it does mean the server will not send any\n    more messages for that consumer.\n  <\/doc><chassisname=\"server\" implement=\"MUST\"><\/chassis><responsename=\"cancel-ok\"><\/response><fieldname=\"consumer tag\" domain=\"consumer tag\"><\/field><fieldtype=\"bit\" name=\"nowait\" type=\"bit\">\n    do not send a reply method\n    <doc>\n    If set, the server will not respond to the method. The client should\n    not wait for a reply method.  If the server could not complete the\n    method it will raise a channel or connection exception.\n    <\/doc><\/field><\/method><methodname=\"cancel-ok\" index=\"31\" synchronous=\"1\">\n  confirm a cancelled consumer\n  <doc>\n    This method confirms that the cancellation was completed.\n  <\/doc><chassisname=\"client\" implement=\"MUST\"><\/chassis><fieldname=\"consumer tag\" domain=\"consumer tag\"><\/field><\/method><methodname=\"open\" index=\"40\" synchronous=\"1\">\n  request to start staging\n  <doc>\n    This method requests permission to start staging a message.  Staging\n    means sending the message into a temporary area at the recipient end\n    and then delivering the message by referring to this temporary area.\n    Staging is how the protocol handles partial file transfers - if a\n    message is partially staged and the connection breaks, the next time\n    the sender starts to stage it, it can restart from where it left off.\n  <\/doc><responsename=\"open-ok\"><\/response><chassisname=\"server\" implement=\"MUST\"><\/chassis><chassisname=\"client\" implement=\"MUST\"><\/chassis><fieldtype=\"shortstr\" name=\"identifier\" type=\"shortstr\">\n    staging identifier\n    <doc>\n      This is the staging identifier. This is an arbitrary string chosen\n      by the sender.  For staging to work correctly the sender must use\n      the same staging identifier when staging the same message a second\n      time after recovery from a failure.  A good choice for the staging\n      identifier would be the SHA1 hash of the message properties data\n      (including the original filename, revised time, etc.).\n    <\/doc><\/field><fieldtype=\"longlong\" name=\"content size\" type=\"longlong\">\n    message content size\n    <doc>\n      The size of the content in octets.  The recipient may use this\n      information to allocate or check available space in advance, to\n      avoid \"disk full\" errors during staging of very large messages.\n    <\/doc><docname=\"rule\">\n      The sender MUST accurately fill the content-size field.\n      Zero-length content is permitted.\n    <\/doc><\/field><\/method><methodname=\"open-ok\" index=\"41\" synchronous=\"1\">\n  confirm staging ready\n  <doc>\n    This method confirms that the recipient is ready to accept staged\n    data.  If the message was already partially-staged at a previous\n    time the recipient will report the number of octets already staged.\n  <\/doc><responsename=\"stage\"><\/response><chassisname=\"server\" implement=\"MUST\"><\/chassis><chassisname=\"client\" implement=\"MUST\"><\/chassis><fieldtype=\"longlong\" name=\"staged size\" type=\"longlong\">\n    already staged amount\n    <doc>\n      The amount of previously-staged content in octets.  For a new\n      message this will be zero.\n    <\/doc><docname=\"rule\">\n      The sender MUST start sending data from this octet offset in the\n      message, counting from zero.\n    <\/doc><docname=\"rule\">\n      The recipient MAY decide how long to hold partially-staged content\n      and MAY implement staging by always discarding partially-staged\n      content.  However if it uses the file content type it MUST support\n      the staging methods.\n    <\/doc><\/field><\/method><methodname=\"stage\" index=\"50\" content=\"1\">\n  stage message content\n  <doc>\n    This method stages the message, sending the message content to the\n    recipient from the octet offset specified in the Open-Ok method.\n  <\/doc><chassisname=\"server\" implement=\"MUST\"><\/chassis><chassisname=\"client\" implement=\"MUST\"><\/chassis><\/method><methodname=\"publish\" index=\"60\">\n  publish a message\n  <doc>\n    This method publishes a staged file message to a specific exchange.\n    The file message will be routed to queues as defined by the exchange\n    configuration and distributed to any active consumers when the\n    transaction, if any, is committed.\n  <\/doc><chassisname=\"server\" implement=\"MUST\"><\/chassis><fieldname=\"ticket\" domain=\"access ticket\"><docname=\"rule\">\n      The client MUST provide a valid access ticket giving \"write\"\n      access rights to the access realm for the exchange.\n    <\/doc><\/field><fieldname=\"exchange\" domain=\"exchange name\"><doc>\n      Specifies the name of the exchange to publish to.  The exchange\n      name can be empty, meaning the default exchange.  If the exchange\n      name is specified, and that exchange does not exist, the server\n      will raise a channel exception.\n    <\/doc><docname=\"rule\">\n      The server MUST accept a blank exchange name to mean the default\n      exchange.\n    <\/doc><docname=\"rule\">\n      If the exchange was declared as an internal exchange, the server\n      MUST respond with a reply code 403 (access refused) and raise a\n      channel exception.\n    <\/doc><docname=\"rule\">\n      The exchange MAY refuse file content in which case it MUST respond\n      with a reply code 540 (not implemented) and raise a channel\n      exception.\n    <\/doc><\/field><fieldtype=\"shortstr\" name=\"routing key\" type=\"shortstr\">\n     Message routing key\n    <doc>\n      Specifies the routing key for the message.  The routing key is\n      used for routing messages depending on the exchange configuration.\n    <\/doc><\/field><fieldtype=\"bit\" name=\"mandatory\" type=\"bit\">\n    indicate mandatory routing\n    <doc>\n      This flag tells the server how to react if the message cannot be\n      routed to a queue.  If this flag is set, the server will return an\n      unroutable message with a Return method.  If this flag is zero, the\n      server silently drops the message.\n    <\/doc><docname=\"rule\" test=\"amq_file_00\">\n      The server SHOULD implement the mandatory flag.\n    <\/doc><\/field><fieldtype=\"bit\" name=\"immediate\" type=\"bit\">\n    request immediate delivery\n    <doc>\n      This flag tells the server how to react if the message cannot be\n      routed to a queue consumer immediately.  If this flag is set, the\n      server will return an undeliverable message with a Return method.\n      If this flag is zero, the server will queue the message, but with\n      no guarantee that it will ever be consumed.\n    <\/doc><docname=\"rule\" test=\"amq_file_00\">\n      The server SHOULD implement the immediate flag.\n    <\/doc><\/field><fieldtype=\"shortstr\" name=\"identifier\" type=\"shortstr\">\n    staging identifier\n    <doc>\n      This is the staging identifier of the message to publish.  The\n      message must have been staged.  Note that a client can send the\n      Publish method asynchronously without waiting for staging to\n      finish.\n    <\/doc><\/field><\/method><methodname=\"return\" index=\"70\" content=\"1\">\n  return a failed message\n  <doc>\n    This method returns an undeliverable message that was published\n    with the \"immediate\" flag set, or an unroutable message published\n    with the \"mandatory\" flag set. The reply code and text provide\n    information about the reason that the message was undeliverable.\n  <\/doc><chassisname=\"client\" implement=\"MUST\"><\/chassis><fieldname=\"reply code\" domain=\"reply code\"><\/field><fieldname=\"reply text\" domain=\"reply text\"><\/field><fieldname=\"exchange\" domain=\"exchange name\"><doc>\n      Specifies the name of the exchange that the message was\n      originally published to.\n    <\/doc><\/field><fieldtype=\"shortstr\" name=\"routing key\" type=\"shortstr\">\n     Message routing key\n    <doc>\n      Specifies the routing key name specified when the message was\n      published.\n    <\/doc><\/field><\/method><methodname=\"deliver\" index=\"80\">\n  notify the client of a consumer message\n  <doc>\n    This method delivers a staged file message to the client, via a\n    consumer. In the asynchronous message delivery model, the client\n    starts a consumer using the Consume method, then the server\n    responds with Deliver methods as and when messages arrive for\n    that consumer.\n  <\/doc><docname=\"rule\">\n    The server SHOULD track the number of times a message has been\n    delivered to clients and when a message is redelivered a certain\n    number of times - e.g. 5 times - without being acknowledged, the\n    server SHOULD consider the message to be unprocessable (possibly\n    causing client applications to abort), and move the message to a\n    dead letter queue.\n  <\/doc><chassisname=\"client\" implement=\"MUST\"><\/chassis><fieldname=\"consumer tag\" domain=\"consumer tag\"><\/field><fieldname=\"delivery tag\" domain=\"delivery tag\"><\/field><fieldname=\"redelivered\" domain=\"redelivered\"><\/field><fieldname=\"exchange\" domain=\"exchange name\"><doc>\n      Specifies the name of the exchange that the message was originally\n      published to.\n    <\/doc><\/field><fieldtype=\"shortstr\" name=\"routing key\" type=\"shortstr\">\n     Message routing key\n    <doc>\n      Specifies the routing key name specified when the message was\n      published.\n    <\/doc><\/field><fieldtype=\"shortstr\" name=\"identifier\" type=\"shortstr\">\n    staging identifier\n    <doc>\n      This is the staging identifier of the message to deliver.  The\n      message must have been staged.  Note that a server can send the\n      Deliver method asynchronously without waiting for staging to\n      finish.\n    <\/doc><\/field><\/method><methodname=\"ack\" index=\"90\">\n  acknowledge one or more messages\n  <doc>\n    This method acknowledges one or more messages delivered via the\n    Deliver method.  The client can ask to confirm a single message or\n    a set of messages up to and including a specific message.\n  <\/doc><chassisname=\"server\" implement=\"MUST\"><\/chassis><fieldname=\"delivery tag\" domain=\"delivery tag\"><\/field><fieldtype=\"bit\" name=\"multiple\" type=\"bit\">\n    acknowledge multiple messages\n    <doc>\n      If set to 1, the delivery tag is treated as \"up to and including\",\n      so that the client can acknowledge multiple messages with a single\n      method.  If set to zero, the delivery tag refers to a single\n      message.  If the multiple field is 1, and the delivery tag is zero,\n      tells the server to acknowledge all outstanding mesages.\n    <\/doc><docname=\"rule\">\n      The server MUST validate that a non-zero delivery-tag refers to an\n      delivered message, and raise a channel exception if this is not the\n      case.\n    <\/doc><\/field><\/method><methodname=\"reject\" index=\"100\">\n  reject an incoming message\n  <doc>\n    This method allows a client to reject a message.  It can be used to\n    return untreatable messages to their original queue.  Note that file\n    content is staged before delivery, so the client will not use this\n    method to interrupt delivery of a large message.\n  <\/doc><docname=\"rule\">\n    The server SHOULD interpret this method as meaning that the client\n    is unable to process the message at this time.\n  <\/doc><docname=\"rule\">\n    A client MUST NOT use this method as a means of selecting messages\n    to process.  A rejected message MAY be discarded or dead-lettered,\n    not necessarily passed to another client.\n  <\/doc><chassisname=\"server\" implement=\"MUST\"><\/chassis><fieldname=\"delivery tag\" domain=\"delivery tag\"><\/field><fieldtype=\"bit\" name=\"requeue\" type=\"bit\">\n    requeue the message\n    <doc>\n      If this field is zero, the message will be discarded.  If this bit\n      is 1, the server will attempt to requeue the message.\n    <\/doc><docname=\"rule\">\n      The server MUST NOT deliver the message to the same client within\n      the context of the current channel.  The recommended strategy is\n      to attempt to deliver the message to an alternative consumer, and\n      if that is not possible, to move the message to a dead-letter\n      queue.  The server MAY use more sophisticated tracking to hold\n      the message on the queue and redeliver it to the same client at\n      a later stage.\n    <\/doc><\/field><\/method><\/class><classname=\"stream\" handler=\"channel\" index=\"80\">\n  work with streaming content\n\n<doc>\n  The stream class provides methods that support multimedia streaming.\n  The stream class uses the following semantics: one message is one\n  packet of data; delivery is unacknowleged and unreliable; the consumer\n  can specify quality of service parameters that the server can try to\n  adhere to; lower-priority messages may be discarded in favour of high\n  priority messages.\n<\/doc><docname=\"grammar\">\n    stream              = C:QOS S:QOS-OK\n                        \/ C:CONSUME S:CONSUME-OK\n                        \/ C:CANCEL S:CANCEL-OK\n                        \/ C:PUBLISH content\n                        \/ S:RETURN\n                        \/ S:DELIVER content\n<\/doc><chassisname=\"server\" implement=\"MAY\"><\/chassis><chassisname=\"client\" implement=\"MAY\"><\/chassis><docname=\"rule\">\n  The server SHOULD discard stream messages on a priority basis if\n  the queue size exceeds some configured limit.\n<\/doc><docname=\"rule\">\n  The server MUST implement at least 2 priority levels for stream\n  messages, where priorities 0-4 and 5-9 are treated as two distinct\n  levels. The server MAY implement up to 10 priority levels.\n<\/doc><docname=\"rule\">\n  The server MUST implement automatic acknowledgements on stream\n  content.  That is, as soon as a message is delivered to a client\n  via a Deliver method, the server must remove it from the queue.\n<\/doc><fieldtype=\"shortstr\" name=\"content type\" type=\"shortstr\">\n    MIME content type\n<\/field><fieldtype=\"shortstr\" name=\"content encoding\" type=\"shortstr\">\n    MIME content encoding\n<\/field><fieldtype=\"table\" name=\"headers\" type=\"table\">\n    Message header field table\n<\/field><fieldtype=\"octet\" name=\"priority\" type=\"octet\">\n    The message priority, 0 to 9\n<\/field><fieldtype=\"timestamp\" name=\"timestamp\" type=\"timestamp\">\n    The message timestamp\n<\/field><methodname=\"qos\" index=\"10\" synchronous=\"1\">\n  specify quality of service\n  <doc>\n    This method requests a specific quality of service.  The QoS can\n    be specified for the current channel or for all channels on the\n    connection.  The particular properties and semantics of a qos method\n    always depend on the content class semantics.  Though the qos method\n    could in principle apply to both peers, it is currently meaningful\n    only for the server.\n  <\/doc><chassisname=\"server\" implement=\"MUST\"><\/chassis><responsename=\"qos-ok\"><\/response><fieldtype=\"long\" name=\"prefetch size\" type=\"long\">\n    prefetch window in octets\n    <doc>\n      The client can request that messages be sent in advance so that\n      when the client finishes processing a message, the following\n      message is already held locally, rather than needing to be sent\n      down the channel.  Prefetching gives a performance improvement.\n      This field specifies the prefetch window size in octets. May be\n      set to zero, meaning \"no specific limit\".  Note that other\n      prefetch limits may still apply.\n    <\/doc><\/field><fieldtype=\"short\" name=\"prefetch count\" type=\"short\">\n    prefetch window in messages\n    <doc>\n      Specifies a prefetch window in terms of whole messages.  This\n      field may be used in combination with the prefetch-size field;\n      a message will only be sent in advance if both prefetch windows\n      (and those at the channel and connection level) allow it.\n    <\/doc><\/field><fieldtype=\"long\" name=\"consume rate\" type=\"long\">\n    transfer rate in octets\/second\n    <doc>\n      Specifies a desired transfer rate in octets per second. This is\n      usually determined by the application that uses the streaming\n      data.  A value of zero means \"no limit\", i.e. as rapidly as\n      possible.\n    <\/doc><docname=\"rule\">\n      The server MAY ignore the prefetch values and consume rates,\n      depending on the type of stream and the ability of the server\n      to queue and\/or reply it.  The server MAY drop low-priority\n      messages in favour of high-priority messages.\n    <\/doc><\/field><fieldtype=\"bit\" name=\"global\" type=\"bit\">\n    apply to entire connection\n    <doc>\n      By default the QoS settings apply to the current channel only.  If\n      this field is set, they are applied to the entire connection.\n    <\/doc><\/field><\/method><methodname=\"qos-ok\" index=\"11\" synchronous=\"1\">\n  confirm the requested qos\n  <doc>\n    This method tells the client that the requested QoS levels could\n    be handled by the server.  The requested QoS applies to all active\n    consumers until a new QoS is defined.\n  <\/doc><chassisname=\"client\" implement=\"MUST\"><\/chassis><\/method><methodname=\"consume\" index=\"20\" synchronous=\"1\">\n  start a queue consumer\n  <doc>\n    This method asks the server to start a \"consumer\", which is a\n    transient request for messages from a specific queue. Consumers\n    last as long as the channel they were created on, or until the\n    client cancels them.\n  <\/doc><docname=\"rule\">\n    The server SHOULD support at least 16 consumers per queue, unless\n    the queue was declared as private, and ideally, impose no limit\n    except as defined by available resources.\n  <\/doc><docname=\"rule\">\n    Streaming applications SHOULD use different channels to select\n    different streaming resolutions. AMQP makes no provision for\n    filtering and\/or transforming streams except on the basis of\n    priority-based selective delivery of individual messages.\n  <\/doc><chassisname=\"server\" implement=\"MUST\"><\/chassis><responsename=\"consume-ok\"><\/response><fieldname=\"ticket\" domain=\"access ticket\"><docname=\"rule\">\n      The client MUST provide a valid access ticket giving \"read\" access\n      rights to the realm for the queue.\n    <\/doc><\/field><fieldname=\"queue\" domain=\"queue name\"><doc>\n      Specifies the name of the queue to consume from.  If the queue name\n      is null, refers to the current queue for the channel, which is the\n      last declared queue.\n    <\/doc><docname=\"rule\">\n      If the client did not previously declare a queue, and the queue name\n      in this method is empty, the server MUST raise a connection exception\n      with reply code 530 (not allowed).\n    <\/doc><\/field><fieldname=\"consumer tag\" domain=\"consumer tag\"><doc>\n      Specifies the identifier for the consumer. The consumer tag is\n      local to a connection, so two clients can use the same consumer\n      tags. If this field is empty the server will generate a unique\n      tag.\n    <\/doc><docname=\"rule\" test=\"todo\">\n      The tag MUST NOT refer to an existing consumer. If the client\n      attempts to create two consumers with the same non-empty tag\n      the server MUST raise a connection exception with reply code\n      530 (not allowed).\n    <\/doc><\/field><fieldname=\"no local\" domain=\"no local\"><\/field><fieldtype=\"bit\" name=\"exclusive\" type=\"bit\">\n    request exclusive access\n    <doc>\n      Request exclusive consumer access, meaning only this consumer can\n      access the queue.\n    <\/doc><docname=\"rule\" test=\"amq_file_00\">\n      If the server cannot grant exclusive access to the queue when asked,\n      - because there are other consumers active - it MUST raise a channel\n      exception with return code 405 (resource locked).\n    <\/doc><\/field><fieldtype=\"bit\" name=\"nowait\" type=\"bit\">\n    do not send a reply method\n    <doc>\n    If set, the server will not respond to the method. The client should\n    not wait for a reply method.  If the server could not complete the\n    method it will raise a channel or connection exception.\n    <\/doc><\/field><\/method><methodname=\"consume-ok\" index=\"21\" synchronous=\"1\">\n  confirm a new consumer\n  <doc>\n    This method provides the client with a consumer tag which it may\n    use in methods that work with the consumer.\n  <\/doc><chassisname=\"client\" implement=\"MUST\"><\/chassis><fieldname=\"consumer tag\" domain=\"consumer tag\"><doc>\n      Holds the consumer tag specified by the client or provided by\n      the server.\n    <\/doc><\/field><\/method><methodname=\"cancel\" index=\"30\" synchronous=\"1\">\n  end a queue consumer\n  <doc>\n    This method cancels a consumer.  Since message delivery is\n    asynchronous the client may continue to receive messages for\n    a short while after canceling a consumer.  It may process or\n    discard these as appropriate.\n  <\/doc><chassisname=\"server\" implement=\"MUST\"><\/chassis><responsename=\"cancel-ok\"><\/response><fieldname=\"consumer tag\" domain=\"consumer tag\"><\/field><fieldtype=\"bit\" name=\"nowait\" type=\"bit\">\n    do not send a reply method\n    <doc>\n    If set, the server will not respond to the method. The client should\n    not wait for a reply method.  If the server could not complete the\n    method it will raise a channel or connection exception.\n    <\/doc><\/field><\/method><methodname=\"cancel-ok\" index=\"31\" synchronous=\"1\">\n  confirm a cancelled consumer\n  <doc>\n    This method confirms that the cancellation was completed.\n  <\/doc><chassisname=\"client\" implement=\"MUST\"><\/chassis><fieldname=\"consumer tag\" domain=\"consumer tag\"><\/field><\/method><methodname=\"publish\" index=\"40\" content=\"1\">\n  publish a message\n  <doc>\n    This method publishes a message to a specific exchange. The message\n    will be routed to queues as defined by the exchange configuration\n    and distributed to any active consumers as appropriate.\n  <\/doc><chassisname=\"server\" implement=\"MUST\"><\/chassis><fieldname=\"ticket\" domain=\"access ticket\"><docname=\"rule\">\n      The client MUST provide a valid access ticket giving \"write\"\n      access rights to the access realm for the exchange.\n    <\/doc><\/field><fieldname=\"exchange\" domain=\"exchange name\"><doc>\n      Specifies the name of the exchange to publish to.  The exchange\n      name can be empty, meaning the default exchange.  If the exchange\n      name is specified, and that exchange does not exist, the server\n      will raise a channel exception.\n    <\/doc><docname=\"rule\">\n      The server MUST accept a blank exchange name to mean the default\n      exchange.\n    <\/doc><docname=\"rule\">\n      If the exchange was declared as an internal exchange, the server\n      MUST respond with a reply code 403 (access refused) and raise a\n      channel exception.\n    <\/doc><docname=\"rule\">\n      The exchange MAY refuse stream content in which case it MUST\n      respond with a reply code 540 (not implemented) and raise a\n      channel exception.\n    <\/doc><\/field><fieldtype=\"shortstr\" name=\"routing key\" type=\"shortstr\">\n     Message routing key\n    <doc>\n      Specifies the routing key for the message.  The routing key is\n      used for routing messages depending on the exchange configuration.\n    <\/doc><\/field><fieldtype=\"bit\" name=\"mandatory\" type=\"bit\">\n    indicate mandatory routing\n    <doc>\n      This flag tells the server how to react if the message cannot be\n      routed to a queue.  If this flag is set, the server will return an\n      unroutable message with a Return method.  If this flag is zero, the\n      server silently drops the message.\n    <\/doc><docname=\"rule\" test=\"amq_stream_00\">\n      The server SHOULD implement the mandatory flag.\n    <\/doc><\/field><fieldtype=\"bit\" name=\"immediate\" type=\"bit\">\n    request immediate delivery\n    <doc>\n      This flag tells the server how to react if the message cannot be\n      routed to a queue consumer immediately.  If this flag is set, the\n      server will return an undeliverable message with a Return method.\n      If this flag is zero, the server will queue the message, but with\n      no guarantee that it will ever be consumed.\n    <\/doc><docname=\"rule\" test=\"amq_stream_00\">\n      The server SHOULD implement the immediate flag.\n    <\/doc><\/field><\/method><methodname=\"return\" index=\"50\" content=\"1\">\n  return a failed message\n  <doc>\n    This method returns an undeliverable message that was published\n    with the \"immediate\" flag set, or an unroutable message published\n    with the \"mandatory\" flag set. The reply code and text provide\n    information about the reason that the message was undeliverable.\n  <\/doc><chassisname=\"client\" implement=\"MUST\"><\/chassis><fieldname=\"reply code\" domain=\"reply code\"><\/field><fieldname=\"reply text\" domain=\"reply text\"><\/field><fieldname=\"exchange\" domain=\"exchange name\"><doc>\n      Specifies the name of the exchange that the message was\n      originally published to.\n    <\/doc><\/field><fieldtype=\"shortstr\" name=\"routing key\" type=\"shortstr\">\n     Message routing key\n    <doc>\n      Specifies the routing key name specified when the message was\n      published.\n    <\/doc><\/field><\/method><methodname=\"deliver\" index=\"60\" content=\"1\">\n  notify the client of a consumer message\n  <doc>\n    This method delivers a message to the client, via a consumer.  In\n    the asynchronous message delivery model, the client starts a\n    consumer using the Consume method, then the server responds with\n    Deliver methods as and when messages arrive for that consumer.\n  <\/doc><chassisname=\"client\" implement=\"MUST\"><\/chassis><fieldname=\"consumer tag\" domain=\"consumer tag\"><\/field><fieldname=\"delivery tag\" domain=\"delivery tag\"><\/field><fieldname=\"exchange\" domain=\"exchange name\"><doc>\n      Specifies the name of the exchange that the message was originally\n      published to.\n    <\/doc><\/field><fieldname=\"queue\" domain=\"queue name\"><doc>\n      Specifies the name of the queue that the message came from. Note\n      that a single channel can start many consumers on different\n      queues.\n    <\/doc><assertcheck=\"notnull\"><\/assert><\/field><\/method><\/class><classname=\"tx\" handler=\"channel\" index=\"90\">\n  work with standard transactions\n\n<doc>\n  Standard transactions provide so-called \"1.5 phase commit\".  We can\n  ensure that work is never lost, but there is a chance of confirmations\n  being lost, so that messages may be resent.  Applications that use\n  standard transactions must be able to detect and ignore duplicate\n  messages.\n<\/doc><ruleimplement=\"SHOULD\">\n  An client using standard transactions SHOULD be able to track all\n  messages received within a reasonable period, and thus detect and\n  reject duplicates of the same message. It SHOULD NOT pass these to\n  the application layer.\n<\/rule><docname=\"grammar\">\n    tx                  = C:SELECT S:SELECT-OK\n                        \/ C:COMMIT S:COMMIT-OK\n                        \/ C:ROLLBACK S:ROLLBACK-OK\n<\/doc><chassisname=\"server\" implement=\"SHOULD\"><\/chassis><chassisname=\"client\" implement=\"MAY\"><\/chassis><methodname=\"select\" index=\"10\" synchronous=\"1\">\nselect standard transaction mode\n  <doc>\n    This method sets the channel to use standard transactions.  The\n    client must use this method at least once on a channel before\n    using the Commit or Rollback methods.\n  <\/doc><chassisname=\"server\" implement=\"MUST\"><\/chassis><responsename=\"select-ok\"><\/response><\/method><methodname=\"select-ok\" index=\"11\" synchronous=\"1\">\nconfirm transaction mode\n  <doc>\n    This method confirms to the client that the channel was successfully\n    set to use standard transactions.\n  <\/doc><chassisname=\"client\" implement=\"MUST\"><\/chassis><\/method><methodname=\"commit\" index=\"20\" synchronous=\"1\">\ncommit the current transaction\n  <doc>\n    This method commits all messages published and acknowledged in\n    the current transaction.  A new transaction starts immediately\n    after a commit.\n  <\/doc><chassisname=\"server\" implement=\"MUST\"><\/chassis><responsename=\"commit-ok\"><\/response><\/method><methodname=\"commit-ok\" index=\"21\" synchronous=\"1\">\nconfirm a successful commit\n  <doc>\n    This method confirms to the client that the commit succeeded.\n    Note that if a commit fails, the server raises a channel exception.\n  <\/doc><chassisname=\"client\" implement=\"MUST\"><\/chassis><\/method><methodname=\"rollback\" index=\"30\" synchronous=\"1\">\nabandon the current transaction\n  <doc>\n    This method abandons all messages published and acknowledged in\n    the current transaction.  A new transaction starts immediately\n    after a rollback.\n  <\/doc><chassisname=\"server\" implement=\"MUST\"><\/chassis><responsename=\"rollback-ok\"><\/response><\/method><methodname=\"rollback-ok\" index=\"31\" synchronous=\"1\">\nconfirm a successful rollback\n  <doc>\n    This method confirms to the client that the rollback succeeded.\n    Note that if an rollback fails, the server raises a channel exception.\n  <\/doc><chassisname=\"client\" implement=\"MUST\"><\/chassis><\/method><\/class><classname=\"dtx\" handler=\"channel\" index=\"100\">\n  work with distributed transactions\n\n<doc>\n  Distributed transactions provide so-called \"2-phase commit\".    The\n  AMQP distributed transaction model supports the X-Open XA\n  architecture and other distributed transaction implementations.\n  The Dtx class assumes that the server has a private communications\n  channel (not AMQP) to a distributed transaction coordinator.\n<\/doc><docname=\"grammar\">\n    dtx                 = C:SELECT S:SELECT-OK\n                          C:START S:START-OK\n<\/doc><chassisname=\"server\" implement=\"MAY\"><\/chassis><chassisname=\"client\" implement=\"MAY\"><\/chassis><methodname=\"select\" index=\"10\" synchronous=\"1\">\nselect standard transaction mode\n  <doc>\n    This method sets the channel to use distributed transactions.  The\n    client must use this method at least once on a channel before\n    using the Start method.\n  <\/doc><chassisname=\"server\" implement=\"MUST\"><\/chassis><responsename=\"select-ok\"><\/response><\/method><methodname=\"select-ok\" index=\"11\" synchronous=\"1\">\nconfirm transaction mode\n  <doc>\n    This method confirms to the client that the channel was successfully\n    set to use distributed transactions.\n  <\/doc><chassisname=\"client\" implement=\"MUST\"><\/chassis><\/method><methodname=\"start\" index=\"20\" synchronous=\"1\">\n  start a new distributed transaction\n  <doc>\n    This method starts a new distributed transaction.  This must be\n    the first method on a new channel that uses the distributed\n    transaction mode, before any methods that publish or consume\n    messages.\n  <\/doc><chassisname=\"server\" implement=\"MAY\"><\/chassis><responsename=\"start-ok\"><\/response><fieldtype=\"shortstr\" name=\"dtx identifier\" type=\"shortstr\">\n    transaction identifier\n    <doc>\n      The distributed transaction key. This identifies the transaction\n      so that the AMQP server can coordinate with the distributed\n      transaction coordinator.\n    <\/doc><assertcheck=\"notnull\"><\/assert><\/field><\/method><methodname=\"start-ok\" index=\"21\" synchronous=\"1\">\n  confirm the start of a new distributed transaction\n  <doc>\n    This method confirms to the client that the transaction started.\n    Note that if a start fails, the server raises a channel exception.\n  <\/doc><chassisname=\"client\" implement=\"MUST\"><\/chassis><\/method><\/class><classname=\"tunnel\" handler=\"tunnel\" index=\"110\">\n  methods for protocol tunneling.\n\n<doc>\n  The tunnel methods are used to send blocks of binary data - which\n  can be serialised AMQP methods or other protocol frames - between\n  AMQP peers.\n<\/doc><docname=\"grammar\">\n    tunnel              = C:REQUEST\n                        \/ S:REQUEST\n<\/doc><chassisname=\"server\" implement=\"MAY\"><\/chassis><chassisname=\"client\" implement=\"MAY\"><\/chassis><fieldtype=\"table\" name=\"headers\" type=\"table\">\n    Message header field table\n<\/field><fieldtype=\"shortstr\" name=\"proxy name\" type=\"shortstr\">\n    The identity of the tunnelling proxy\n<\/field><fieldtype=\"shortstr\" name=\"data name\" type=\"shortstr\">\n    The name or type of the message being tunnelled\n<\/field><fieldtype=\"octet\" name=\"durable\" type=\"octet\">\n    The message durability indicator\n<\/field><fieldtype=\"octet\" name=\"broadcast\" type=\"octet\">\n    The message broadcast mode\n<\/field><methodname=\"request\" index=\"10\" content=\"1\">\n  sends a tunnelled method\n  <doc>\n    This method tunnels a block of binary data, which can be an\n    encoded AMQP method or other data.  The binary data is sent\n    as the content for the Tunnel.Request method.\n  <\/doc><chassisname=\"server\" implement=\"MUST\"><\/chassis><fieldtype=\"table\" name=\"meta data\" type=\"table\">\n    meta data for the tunnelled block\n    <doc>\n    This field table holds arbitrary meta-data that the sender needs\n    to pass to the recipient.\n    <\/doc><\/field><\/method><\/class><classname=\"test\" handler=\"channel\" index=\"120\">\n  test functional primitives of the implementation\n\n<doc>\n  The test class provides methods for a peer to test the basic\n  operational correctness of another peer. The test methods are\n  intended to ensure that all peers respect at least the basic\n  elements of the protocol, such as frame and content organisation\n  and field types. We assume that a specially-designed peer, a\n  \"monitor client\" would perform such tests.\n<\/doc><docname=\"grammar\">\n    test                = C:INTEGER S:INTEGER-OK\n                        \/ S:INTEGER C:INTEGER-OK\n                        \/ C:STRING S:STRING-OK\n                        \/ S:STRING C:STRING-OK\n                        \/ C:TABLE S:TABLE-OK\n                        \/ S:TABLE C:TABLE-OK\n                        \/ C:CONTENT S:CONTENT-OK\n                        \/ S:CONTENT C:CONTENT-OK\n<\/doc><chassisname=\"server\" implement=\"MUST\"><\/chassis><chassisname=\"client\" implement=\"SHOULD\"><\/chassis><methodname=\"integer\" index=\"10\" synchronous=\"1\">\n  test integer handling\n  <doc>\n    This method tests the peer's capability to correctly marshal integer\n    data.\n  <\/doc><chassisname=\"client\" implement=\"MUST\"><\/chassis><chassisname=\"server\" implement=\"MUST\"><\/chassis><responsename=\"integer-ok\"><\/response><fieldtype=\"octet\" name=\"integer 1\" type=\"octet\">\n    octet test value\n    <doc>\n      An octet integer test value.\n    <\/doc><\/field><fieldtype=\"short\" name=\"integer 2\" type=\"short\">\n    short test value\n    <doc>\n      A short integer test value.\n    <\/doc><\/field><fieldtype=\"long\" name=\"integer 3\" type=\"long\">\n    long test value\n    <doc>\n      A long integer test value.\n    <\/doc><\/field><fieldtype=\"longlong\" name=\"integer 4\" type=\"longlong\">\n    long-long test value\n    <doc>\n      A long long integer test value.\n    <\/doc><\/field><fieldtype=\"octet\" name=\"operation\" type=\"octet\">\n    operation to test\n    <doc>\n      The client must execute this operation on the provided integer\n      test fields and return the result.\n    <\/doc><assertcheck=\"enum\"><valuename=\"add\">return sum of test values<\/value><valuename=\"min\">return lowest of test values<\/value><valuename=\"max\">return highest of test values<\/value><\/assert><\/field><\/method><methodname=\"integer-ok\" index=\"11\" synchronous=\"1\">\n  report integer test result\n  <doc>\n    This method reports the result of an Integer method.\n  <\/doc><chassisname=\"client\" implement=\"MUST\"><\/chassis><chassisname=\"server\" implement=\"MUST\"><\/chassis><fieldtype=\"longlong\" name=\"result\" type=\"longlong\">\n    result value\n    <doc>\n      The result of the tested operation.\n    <\/doc><\/field><\/method><methodname=\"string\" index=\"20\" synchronous=\"1\">\n  test string handling\n  <doc>\n    This method tests the peer's capability to correctly marshal string\n    data.\n  <\/doc><chassisname=\"client\" implement=\"MUST\"><\/chassis><chassisname=\"server\" implement=\"MUST\"><\/chassis><responsename=\"string-ok\"><\/response><fieldtype=\"shortstr\" name=\"string 1\" type=\"shortstr\">\n    short string test value\n    <doc>\n      An short string test value.\n    <\/doc><\/field><fieldtype=\"longstr\" name=\"string 2\" type=\"longstr\">\n    long string test value\n    <doc>\n      A long string test value.\n    <\/doc><\/field><fieldtype=\"octet\" name=\"operation\" type=\"octet\">\n    operation to test\n    <doc>\n      The client must execute this operation on the provided string\n      test fields and return the result.\n    <\/doc><assertcheck=\"enum\"><valuename=\"add\">return concatentation of test strings<\/value><valuename=\"min\">return shortest of test strings<\/value><valuename=\"max\">return longest of test strings<\/value><\/assert><\/field><\/method><methodname=\"string-ok\" index=\"21\" synchronous=\"1\">\n  report string test result\n  <doc>\n    This method reports the result of a String method.\n  <\/doc><chassisname=\"client\" implement=\"MUST\"><\/chassis><chassisname=\"server\" implement=\"MUST\"><\/chassis><fieldtype=\"longstr\" name=\"result\" type=\"longstr\">\n    result value\n    <doc>\n      The result of the tested operation.\n    <\/doc><\/field><\/method><methodname=\"table\" index=\"30\" synchronous=\"1\">\n  test field table handling\n  <doc>\n    This method tests the peer's capability to correctly marshal field\n    table data.\n  <\/doc><chassisname=\"client\" implement=\"MUST\"><\/chassis><chassisname=\"server\" implement=\"MUST\"><\/chassis><responsename=\"table-ok\"><\/response><fieldtype=\"table\" name=\"table\" type=\"table\">\n    field table of test values\n    <doc>\n      A field table of test values.\n    <\/doc><\/field><fieldtype=\"octet\" name=\"integer op\" type=\"octet\">\n    operation to test on integers\n    <doc>\n      The client must execute this operation on the provided field\n      table integer values and return the result.\n    <\/doc><assertcheck=\"enum\"><valuename=\"add\">return sum of numeric field values<\/value><valuename=\"min\">return min of numeric field values<\/value><valuename=\"max\">return max of numeric field values<\/value><\/assert><\/field><fieldtype=\"octet\" name=\"string op\" type=\"octet\">\n    operation to test on strings\n    <doc>\n      The client must execute this operation on the provided field\n      table string values and return the result.\n    <\/doc><assertcheck=\"enum\"><valuename=\"add\">return concatenation of string field values<\/value><valuename=\"min\">return shortest of string field values<\/value><valuename=\"max\">return longest of string field values<\/value><\/assert><\/field><\/method><methodname=\"table-ok\" index=\"31\" synchronous=\"1\">\n  report table test result\n  <doc>\n    This method reports the result of a Table method.\n  <\/doc><chassisname=\"client\" implement=\"MUST\"><\/chassis><chassisname=\"server\" implement=\"MUST\"><\/chassis><fieldtype=\"longlong\" name=\"integer result\" type=\"longlong\">\n    integer result value\n    <doc>\n      The result of the tested integer operation.\n    <\/doc><\/field><fieldtype=\"longstr\" name=\"string result\" type=\"longstr\">\n    string result value\n    <doc>\n      The result of the tested string operation.\n    <\/doc><\/field><\/method><methodname=\"content\" index=\"40\" content=\"1\" synchronous=\"1\">\n  test content handling\n  <doc>\n    This method tests the peer's capability to correctly marshal content.\n  <\/doc><chassisname=\"client\" implement=\"MUST\"><\/chassis><chassisname=\"server\" implement=\"MUST\"><\/chassis><responsename=\"content-ok\"><\/response><\/method><methodname=\"content-ok\" index=\"41\" content=\"1\" synchronous=\"1\">\n  report content test result\n  <doc>\n    This method reports the result of a Content method.  It contains the\n    content checksum and echoes the original content as provided.\n  <\/doc><chassisname=\"client\" implement=\"MUST\"><\/chassis><chassisname=\"server\" implement=\"MUST\"><\/chassis><fieldtype=\"long\" name=\"content checksum\" type=\"long\">\n    content hash\n    <doc>\n      The 32-bit checksum of the content, calculated by adding the\n      content into a 32-bit accumulator.\n    <\/doc><\/field><\/method><\/class>"
}